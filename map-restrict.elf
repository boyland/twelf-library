%%%%% map-restrict.elf
%%%%% Restricting a map to a domain inside a set.
%%%%% This file is one of the add-ons to the map ``functor''
%%%%% It requires set and map-base and 
%%%%% optionally map-domain, map-leq, map-join, map-scale


%%%% Definitions


%%% restriction

restrict : map -> set -> map -> type.


restrict/0 : restrict map/0 _ map/0.

restrict/out :
	restrict M1 S M2 ->
	not-member S N ->
	fresh M1 N ->
	update M1 N D M1P ->
    restrict M1P S M2.

restrict/in :
	restrict M1 S M2 ->
	member S N ->
	fresh M1 N ->
	update M1 N D M1P ->
	update M2 N D M2P ->
    restrict M1P S M2P.




%%%% Theorems


%%% Theorems about restrict


%theorem false-implies-restrict :
	forall* {S1} {S2} {S3}
	forall {F:void}
	exists {D:restrict S1 S2 S3}
	true.

%worlds () (false-implies-restrict _ _).
%total {} (false-implies-restrict _ _).


%theorem restrict-respects-eq :
	forall* {S1} {S2} {S3} {T1} {T2} {T3}
	forall {DS:restrict S1 S2 S3}
               {E1:eq S1 T1} {E2:set`eq S2 T2} {E3:eq S3 T3}
	exists {DT:restrict T1 T2 T3}
	true.

- : restrict-respects-eq R eq/ set`eq/ eq/ R.

%worlds () (restrict-respects-eq _ _ _ _ _).
%total {} (restrict-respects-eq _ _ _ _ _).
%reduces R = RP (restrict-respects-eq R _ _ _ RP).


%theorem restrict-total* :
	forall {S1} {S2}
	exists {S3} {R:restrict S1 S2 S3}
	true.

%abbrev restrict-total = restrict-total* _ _ _.

%theorem restrict-total/L1 :
        forall* {A} {S}
	forall	{N}
	       	{Z: size A N}
        exists	{C} 
		{R:restrict A S C}
	true.

- : restrict-total/L1 nat`z _ _ restrict/0.

%theorem restrict-total/L2 :
        forall* {A} {S} {X} {B} {D}
	forall	{N}
	       	{Z: size A N}
		{L: lookup A X D}
		{M: set`member? S X B}
        exists	{C} 
		{R:restrict A S C}
	true.

- : restrict-total/L1 (s _) Z _ R
    <- set`member?-total M?
    <- restrict-total/L2 _ Z (lookup/= nat`eq/) M? _ R.

- : restrict-total/L2 (s _) Z L (set`member?/in S<-X) _
	(restrict/in R1 S<-X A1</-X A1+X->D=A C1+X->D=C)
    <- lookup-implies-fresh-update L _ A1</-X A1+X->D=A 
    <- fresh-update-increases-size-converse Z A1</-X A1+X->D=A Z1
    <- restrict-total/L1 _ Z1 _ R1
    <- update-total C1+X->D=C.

- : restrict-total/L2 (s _) Z L (set`member?/out S</-X) _
	(restrict/out R1 S</-X A1</-X A1+X->D=A)
    <- lookup-implies-fresh-update L _ A1</-X A1+X->D=A 
    <- fresh-update-increases-size-converse Z A1</-X A1+X->D=A Z1
    <- restrict-total/L1 _ Z1 _ R1.

%worlds () (restrict-total/L2 _ _ _ _ _ _)
	   (restrict-total/L1 _ _ _ _).
%total (N2 N1) 
	   (restrict-total/L2 N2 _ _ _ _ _)
	   (restrict-total/L1 N1 _ _ _).

- : restrict-total R
    <- size-total SZ
    <- restrict-total/L1 _ SZ _ R.

%worlds () (restrict-total* _ _ _ _).
%total { } (restrict-total* _ _ _ _).


%theorem restrict/in-inversion:
	forall*	{A} {S} {C} {N} {D} {A1}
	forall	{R: restrict A S C}
		{M: member S N}
		{F: fresh A1 N}
		{U: update A1 N D A}
	exists	{C1}
		{R1: restrict A1 S C1}
		{U1: update C1 N D C}
	true.

%theorem restrict/in-inversion/in:
	forall* {A0} {S} {C0} {N0} {D0} {N} {D} {A1} {A} {C} {B}
	forall	{R0: restrict A0 S C0}
		{M0: member S N0}
		{F0: fresh A0 N0}
		{UA: update A0 N0 D0 A}
		{UC: update C0 N0 D0 C}
		{M: member S N}
		{F: fresh A1 N}
		{U: update A1 N D A}
		{NEQ?: nat`eq? N N0 B}
	exists	{C1}
		{R1: restrict A1 S C1}
		{U1: update C1 N D C}
	true.

- : restrict/in-inversion/in R0 M0 F0 UA UC M F U (nat`eq?/yes) _ R0P UCP
    <- fresh-update-cancels F0 UA F U nat`eq/ eq/ D0=D A0=A1
    <- restrict-respects-eq R0 A0=A1 set`eq/ eq/ R0P
    <- update-respects-eq UC eq/ nat`eq/ D0=D eq/ UCP.

- : restrict/in-inversion/in R0 M0 F0 UA UC M F U (nat`eq?/no N<>N0) _
	(restrict/in R2 M0 F2 UA1 UC1) UC3
    <- update-commutes-converse U UA N<>N0 _ UA1 U1
    <- update-preserves-fresh-converse F UA1 F1
    <- restrict/in-inversion R0 M F1 U1 _ R2 UC2
    <- update-preserves-fresh-converse F0 U1 F2
    <- update-commutes UC2 UC N<>N0 _ UC1 UC3.

- : restrict/in-inversion 
	(restrict/in R0 M0 F0 UA0 UC0) M F U _ R UC
    <- nat`eq?-total NEQ?
    <- restrict/in-inversion/in R0 M0 F0 UA0 UC0 M F U NEQ? _ R UC.

- : restrict/in-inversion
	(restrict/out R0 NM0 F0 UA0) M F U _ 
	(restrict/out R2 NM0 F2 UA1) UC
    <- not-member-member-not-equal NM0 M (NE:nat`ne N0 N)
    <- update-commutes-converse UA0 U NE _ U1 UA1
    <- update-preserves-fresh-converse F UA1 F1
    <- restrict/in-inversion R0 M F1 U1 _ R2 UC
    <- update-preserves-fresh-converse F0 U1 F2.

%worlds () (restrict/in-inversion _ _ _ _ _ _ _)
	   (restrict/in-inversion/in _ _ _ _ _ _ _ _ _ _ _ _).
%total (R R1) (restrict/in-inversion R _ _ _ _ _ _)
	   (restrict/in-inversion/in R1 _ _ _ _ _ _ _ _ _ _ _).

%theorem restrict/out-inversion:
	forall*	{A} {S} {C} {N} {D} {A1}
	forall	{R: restrict A S C}
		{NM: not-member S N}
		{F: fresh A1 N}
		{U: update A1 N D A}
	exists	{R1: restrict A1 S C}
	true.

%theorem restrict/out-inversion/out:
	forall* {A0} {S} {N0} {D0} {N} {D} {A1} {A} {C} {B}
	forall	{R0: restrict A0 S C}
		{M0: not-member S N0}
		{F0: fresh A0 N0}
		{UA: update A0 N0 D0 A}
		{NM: not-member S N}
		{F: fresh A1 N}
		{U: update A1 N D A}
		{NEQ?: nat`eq? N N0 B}
	exists	{R1: restrict A1 S C}
	true.

- : restrict/out-inversion/out R0 NM0 F0 UA0 NM F U (nat`eq?/yes) R0P
    <- fresh-update-cancels F0 UA0 F U nat`eq/ eq/ D0=D A0=A1
    <- restrict-respects-eq R0 A0=A1 set`eq/ eq/ R0P.

- : restrict/out-inversion/out R0 NM0 F0 UA0 NM F U (nat`eq?/no N<>N0) 
	(restrict/out R2 NM0 F2 UA1)
    <- update-commutes-converse U UA0 N<>N0 _ UA1 U1
    <- update-preserves-fresh-converse F UA1 F1
    <- restrict/out-inversion R0 NM F1 U1 R2
    <- update-preserves-fresh-converse F0 U1 F2.

- : restrict/out-inversion
	(restrict/out R0 NM0 F0 UA0) NM F U R
    <- nat`eq?-total NEQ?
    <- restrict/out-inversion/out R0 NM0 F0 UA0 NM F U NEQ? R.

- : restrict/out-inversion
	(restrict/in R0 M0 F0 UA0 UC) NM F U
	(restrict/in R2 M0 F2 UA1 UC)
    <- not-member-member-not-equal NM M0 (N<>N0:nat`ne N N0)
    <- update-commutes-converse U UA0 N<>N0 _ UA1 U1
    <- update-preserves-fresh-converse F UA1 F1
    <- restrict/out-inversion R0 NM F1 U1 R2
    <- update-preserves-fresh-converse F0 U1 F2.

%worlds () (restrict/out-inversion _ _ _ _ _)
	   (restrict/out-inversion/out _ _ _ _ _ _ _ _ _).
%total (R R1) (restrict/out-inversion R _ _ _ _)
	   (restrict/out-inversion/out R1 _ _ _ _ _ _ _ _).


%theorem restrict-unique :
	forall* {S1} {S2} {S3} {T1} {T2} {T3}
	forall {RS:restrict S1 S2 S3} {RT:restrict T1 T2 T3}
	       {E1:eq S1 T1} {E2:set`eq S2 T2}
	exists {E3:eq S3 T3}
	true.

%abbrev restrict-deterministic = restrict-unique.

- : restrict-unique restrict/0 restrict/0 _ _ eq/.

- : restrict-unique 
	(restrict/in R1 M1 F1 UA1 UC1) R eq/ set`eq/ NEQ
    <- restrict/in-inversion R M1 F1 UA1 _ R2 UC2
    <- restrict-unique R1 R2 eq/ set`eq/ C1=C2
    <- update-unique UC1 UC2 C1=C2 nat`eq/ data`eq/ NEQ.
	
- : restrict-unique
	(restrict/out R1 NM1 F1 U1) R eq/ set`eq/ NEQ
    <- restrict/out-inversion R NM1 F1 U1 R2
    <- restrict-unique R1 R2 eq/ set`eq/ NEQ.

%worlds () (restrict-unique _ _ _ _ _).
%total (R) (restrict-unique R _ _ _ _).


%theorem restrict-preserves-lookup:
	forall* {A} {S} {C} {X} {D}
	forall	{L: lookup A X D}
		{R: restrict A S C}
		{L: set`member S X}
	exists	{L: lookup C X D}
	true.

- : restrict-preserves-lookup LA R M LC
    <- lookup-implies-fresh-update LA _ F UA
    <- restrict/in-inversion R M F UA _ R1 UC
    <- update-implies-lookup UC LC.

%worlds () (restrict-preserves-lookup _ _ _ _).
%total { } (restrict-preserves-lookup _ _ _ _).


%theorem restrict-preserves-fresh:
	forall*	{A} {N} {S} {C}
	forall	{FA: fresh A N}
		{R: restrict A S C}
	exists	{FC: fresh C N}
	true.

- : restrict-preserves-fresh _ restrict/0 fresh/0.

- : restrict-preserves-fresh FAP (restrict/in R M F U UP) FCP
    <- update-implies-lookup U L
    <- fresh-lookup-not-equal FAP L N<>N0
    <- update-preserves-fresh-converse FAP U FA
    <- restrict-preserves-fresh FA R FC
    <- update-preserves-fresh FC UP N<>N0 FCP.

- : restrict-preserves-fresh FAP (restrict/out R _ _ U) FC
    <- update-preserves-fresh-converse FAP U FA
    <- restrict-preserves-fresh FA R FC.

%worlds () (restrict-preserves-fresh _ _ _).
%total (R) (restrict-preserves-fresh _ R _).


%theorem restrict-preserves-lookup-converse:
	forall*	{A} {N} {S} {C} {D}
	forall	{LC: lookup C N D}
		{R: restrict A S C}
	exists	{LA: lookup A N D}
		{SM: member S N}
	true.

%theorem restrict-preserves-lookup-converse/L:
	forall*	{A} {N} {S} {C} {D} {B} {B1}
	forall	{LC: lookup C N D}
		{R: restrict A S C}
		{D?: domain? A N B}
		{M?: member? S N B1}
	exists	{LA: lookup A N D}
		{SM: member S N}
	true.

- : restrict-preserves-lookup-converse/L LC R (domain?/in LAP) (member?/in M) LA M
    <- lookup-implies-fresh-update LAP _ F U
    <- restrict/in-inversion R M F U _ R1 UP
    <- update-implies-lookup UP LCP
    <- lookup-unique LCP LC eq/ nat`eq/ DP=D
    <- lookup-respects-eq LAP eq/ nat`eq/ DP=D LA.

- : restrict-preserves-lookup-converse/L LC R (domain?/out FA) _ LA M
    <- restrict-preserves-fresh FA R FC
    <- fresh-lookup-not-equal FC LC N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F LA
    <- false-implies-member F M.

- : restrict-preserves-lookup-converse/L LC R (domain?/in LA) (member?/out NM) L M
    <- lookup-implies-fresh-update LA _ FA U
    <- restrict/out-inversion R NM FA U R2
    <- restrict-preserves-fresh FA R2 FC
    <- fresh-lookup-not-equal FC LC N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L
    <- false-implies-member F M.

%worlds () (restrict-preserves-lookup-converse/L _ _ _ _ _ _).
%total { } (restrict-preserves-lookup-converse/L _ _ _ _ _ _).

- : restrict-preserves-lookup-converse LC R LA M
    <- domain?-total D?
    <- member?-total M?
    <- restrict-preserves-lookup-converse/L LC R D? M? LA M.

%worlds () (restrict-preserves-lookup-converse _ _ _ _).
%total { } (restrict-preserves-lookup-converse _ _ _ _).


%theorem restrict-not-member-implies-fresh:
	forall* {A} {S} {C} {X}
	forall	{R: restrict A S C}
		{L: set`not-member S X}
	exists	{L: fresh C X}
	true.

%theorem restrict-not-member-implies-fresh/L:
	forall* {A} {S} {C} {X} {B}
	forall	{R: restrict A S C}
		{L: set`not-member S X}
		{D: domain? C X B}
	exists	{L: fresh C X}
	true.

- : restrict-not-member-implies-fresh/L _ _ (domain?/out F) F.

- : restrict-not-member-implies-fresh/L R NM (domain?/in CL) CF
    <- restrict-preserves-lookup-converse CL R AL M
    <- member-not-member-contradiction M NM F
    <- false-implies-fresh F CF.

%worlds () (restrict-not-member-implies-fresh/L _ _ _ _).
%total { } (restrict-not-member-implies-fresh/L _ _ _ _).

- : restrict-not-member-implies-fresh R NM F
    <- domain?-total D?
    <- restrict-not-member-implies-fresh/L R NM D? F.

%worlds () (restrict-not-member-implies-fresh _ _ _).
%total { } (restrict-not-member-implies-fresh _ _ _).


%theorem restrict-left-preserves-disjoint:
	forall*	{A} {C} {E} {S} {T}
	forall	{D: set`disjoint S T}
		{R1: restrict A S C}
		{R2: restrict A T E}
	exists	{D: disjoint C E}
	true.

- : restrict-left-preserves-disjoint _ restrict/0 restrict/0 disjoint/R.

- : restrict-left-preserves-disjoint S^T
	(restrict/in R1 M1 F1 U1 U1P) R C1P^C2P
    <- disjoint-member-implies-not-member M1 S^T NM2
    <- restrict/out-inversion R NM2 F1 U1 R2
    <- restrict-left-preserves-disjoint S^T R1 R2 C1^C2P
    <- restrict-preserves-fresh F1 R2 F2P
    <- disjoint-symmetric C1^C2P C2P^C1
    <- fresh-update-preserves-disjoint C2P^C1 F2P U1P C2P^C1P
    <- disjoint-symmetric C2P^C1P C1P^C2P.

%theorem restrict-left-preserves-disjoint/L :
	forall*	{S} {T} {A1} {C1} {N} {X} {A1P} {C2P} {B}
	forall	{D: set`disjoint S T}
		{R1: restrict A1 S C1}
		{NM1: not-member S N}
		{F1: fresh A1 N}
		{U1: update A1 N X A1P}
		{R2P: restrict A1P T C2P}
		{M?: member? T N B}
	exists	{D: disjoint C1 C2P}
	true.

- : restrict-left-preserves-disjoint/L S^T R1 NM1 F1 U1 R2P
	(member?/in M2) C1^C2P
    <- restrict/in-inversion R2P M2 F1 U1 _ R2 U2
    <- restrict-left-preserves-disjoint S^T R1 R2 C1^C2
    <- restrict-preserves-fresh F1 R1 F1P
    <- fresh-update-preserves-disjoint C1^C2 F1P U2 C1^C2P.

- : restrict-left-preserves-disjoint/L S^T R1 NM1 F1 U1 R2P
	(member?/out NM2) C1^C2
    <- restrict/out-inversion R2P NM2 F1 U1 R2
    <- restrict-left-preserves-disjoint S^T R1 R2 C1^C2.

- : restrict-left-preserves-disjoint S^T
	(restrict/out R1 NM1 F1 U1) R C1^C2P
    <- member?-total M?
    <- restrict-left-preserves-disjoint/L S^T R1 NM1 F1 U1 R M? C1^C2P.

%worlds () (restrict-left-preserves-disjoint _ _ _ _)
	(restrict-left-preserves-disjoint/L _ _ _ _ _ _ _ _).
%total (R1 R2) (restrict-left-preserves-disjoint _ R1 _ _)
	(restrict-left-preserves-disjoint/L _ R2 _ _ _ _ _ _).


%theorem restrict-right-preserves-disjoint:
	forall*	{A} {C} {E} {G} {S} {T}
	forall	{D: disjoint A E}
		{R1: restrict A S C}
		{R2: restrict E T G}
	exists	{D: disjoint C G}
	true.

%theorem restrict-right-preserves-disjoint/L:
	forall*	{A} {C} {E} {G} {S} {T} {B}
	forall	{D: disjoint A E}
		{R1: restrict A S C}
		{R2: restrict E T G}
		{D: disjoint? C G B}
	exists	{D: disjoint C G}
	true.

- : restrict-right-preserves-disjoint/L A^E A|S=C E|T=G (disjoint?/yes C^G) C^G.

- : restrict-right-preserves-disjoint/L A^E A|S=C E|T=G 
	(disjoint?/no LC LG) C^G
    <- restrict-preserves-lookup-converse LC A|S=C LA _
    <- restrict-preserves-lookup-converse LG E|T=G LE _
    <- disjoint-lookup-contradiction A^E LA LE F
    <- false-implies-disjoint F C^G.

%worlds () (restrict-right-preserves-disjoint/L _ _ _ _ _).
%total { } (restrict-right-preserves-disjoint/L _ _ _ _ _).

- : restrict-right-preserves-disjoint A^E A|S=C E|T=G C^G
    <- disjoint?-total D?
    <- restrict-right-preserves-disjoint/L A^E A|S=C E|T=G D? C^G.

%worlds () (restrict-right-preserves-disjoint _ _ _ _).
%total { } (restrict-right-preserves-disjoint _ _ _ _).


%theorem fresh-add-preserves-restrict:
	forall*	{A} {B1} {C} {B2} {N}
	forall	{R1: restrict A B1 C}
		{F: fresh A N}
		{U: set`add B1 N B2}
	exists	{R2: restrict A B2 C}
	true.

- : fresh-add-preserves-restrict restrict/0 _ _ restrict/0.

- : fresh-add-preserves-restrict
	(restrict/in R1 B1->N F1 U1 UP1) F A
	(restrict/in R2 B2->N F1 U1 UP1)
    <- update-preserves-fresh-converse F U1 FP
    <- fresh-add-preserves-restrict R1 FP A R2
    <- add-preserves-member B1->N A B2->N.

- : fresh-add-preserves-restrict
	(restrict/out R1 B1-/>N F1 U1) F A
	(restrict/out R2 B2-/>N F1 U1)
    <- update-preserves-fresh-converse F U1 FP
    <- fresh-add-preserves-restrict R1 FP A R2
    <- update-implies-lookup U1 L1
    <- fresh-lookup-not-equal F L1 NEs
    <- nat`ne-symmetric NEs NE
    <- add-preserves-not-member B1-/>N A NE B2-/>N.

%worlds () (fresh-add-preserves-restrict _ _ _ _).
%total (R) (fresh-add-preserves-restrict R _ _ _).


%theorem fresh-add-preserves-restrict-converse:
	forall*	{A} {B1} {C} {B2} {N}
	forall	{R1: restrict A B2 C}
		{F: fresh A N}
		{U: set`add B1 N B2}
	exists	{R2: restrict A B1 C}
	true.

- : fresh-add-preserves-restrict-converse A|B2=C F SA A|B1=C
    <- restrict-total A|B1=CX
    <- fresh-add-preserves-restrict A|B1=CX F SA A|B2=CX
    <- restrict-unique A|B2=CX A|B2=C eq/ set`eq/ CX=C
    <- restrict-respects-eq A|B1=CX eq/ set`eq/ CX=C A|B1=C.

%worlds () (fresh-add-preserves-restrict-converse _ _ _ _).
%total { } (fresh-add-preserves-restrict-converse _ _ _ _).


%theorem restrict-commute-update*:
	forall*	{A1} {B1} {C1} {N} {D}
		{A2} {B2} {C2}
	forall	{R1: restrict A1 B1 C1}
		{UA: update A1 N D A2}
		{A: set`add B1 N B2}
		{UC: update C1 N D C2}
	exists	{R2: restrict A2 B2 C2}
	true.

%theorem restrict-commute-update/L:
	forall*	{A1} {B1} {C1} {N} {D}
		{A2} {B2} {C2} {B} {BP}
	forall	{R1: restrict A1 B1 C1}
		{UA: update A1 N D A2}
		{A: set`add B1 N B2}
		{UC: update C1 N D C2}
		{D?: domain? A1 N B}
		{M?: member? B1 N BP}
	exists	{R2: restrict A2 B2 C2}
	true.

- : restrict-commute-update/L 
	R UA B1+N=B2 UC (domain?/out FA) _
	(restrict/in RP B2->N FA UA UC)
    <- fresh-add-preserves-restrict R FA B1+N=B2 RP
    <- add-implies-member B1+N=B2 B2->N.

- : restrict-commute-update/L
	R1 UA1 B1+N=B2 UC1 (domain?/in LA) (member?/in B1->N)
	(restrict/in R3 B2->N FA2 UA3 UC3)
    <- lookup-implies-fresh-update LA _ FA2 UA2
    <- restrict/in-inversion R1 B1->N FA2 UA2 _ R2 UC2
    <- fresh-add-preserves-restrict R2 FA2 B1+N=B2 R3
    <- add-implies-member B1+N=B2 B2->N
    <- update-overwrites UA2 UA1 nat`eq/ UA3
    <- update-overwrites UC2 UC1 nat`eq/ UC3.

- : restrict-commute-update/L
	R1 UA1 B1+N=B2 UC1 (domain?/in LA) (member?/out B1-/>N)
	(restrict/in R3 B2->N FA2 UA3 UC1)
    <- lookup-implies-fresh-update LA _ FA2 UA2
    <- restrict/out-inversion R1 B1-/>N FA2 UA2 R2
    <- fresh-add-preserves-restrict R2 FA2 B1+N=B2 R3
    <- add-implies-member B1+N=B2 B2->N
    <- update-overwrites UA2 UA1 nat`eq/ UA3.

%worlds () (restrict-commute-update/L _ _ _ _ _ _ _).
%total { } (restrict-commute-update/L _ _ _ _ _ _ _).

- : restrict-commute-update* R UA AB UC RP
    <- domain?-total D?
    <- member?-total M?
    <- restrict-commute-update/L R UA AB UC D? M? RP.

%worlds () (restrict-commute-update* _ _ _ _ _).
%total { } (restrict-commute-update* _ _ _ _ _).


%theorem restrict-reorders :
	forall*	{A} {B} {C} {D} {E}
	forall	{R1: restrict A B C}
		{R2: restrict C D E}
	exists	{F}
		{R3: restrict A D F}
		{R4: restrict F B E}
	true.

- : restrict-reorders restrict/0 restrict/0 _ restrict/0 restrict/0.

%theorem restrict-reorders/out:
	forall*	{A} {S} {C} {T} {E} {N} {B} {AP} {D}
	forall	{R1: restrict A S C}
		{R2: restrict C T E}
		{M?: member? S N B}
		{NM: not-member T N}
		{FA: fresh A N}
		{UA: update A N D AP}
	exists	{CP}
		{R3: restrict AP S CP}
		{R4: restrict CP T E}
	true.

- : restrict-reorders/out R1 R2 (member?/in M1) NM2 FA UA _ 
	(restrict/in R1 M1 FA UA UC)
	(restrict/out R2 NM2 FC UC)
    <- restrict-preserves-fresh FA R1 FC
    <- update-total UC.

- : restrict-reorders/out R1 R2 (member?/out NM1) NM2 FA UA _
	(restrict/out R1 NM1 FA UA) R2.

%worlds () (restrict-reorders/out _ _ _ _ _ _ _ _ _).
%total { } (restrict-reorders/out _ _ _ _ _ _ _ _ _).

- : restrict-reorders 
	(restrict/out A1|S=C S-/>N FA1 UA) C|T=E _
	R3 R4
     <- restrict-reorders A1|S=C C|T=E _ A1|T=F1 F1|S=E
     <- member?-total M?
     <- restrict-reorders/out A1|T=F1 F1|S=E M? S-/>N FA1 UA _ R3 R4.

%theorem restrict-reorders/in :
	forall* {A1} {S} {C1} {N} {D} {A2} {C2} {T} {E} {B}
	forall	{R1: restrict A1 S C1}
		{M: member S N}
		{FA: fresh A1 N}
		{UA: update A1 N D A2}
		{UC: update C1 N D C2}
		{R2: restrict C2 T E}
		{M?: member? T N B}
	exists	{F}
		{R3: restrict A2 T F}
		{R4: restrict F S E}
	true.

- : restrict-reorders/in A1|S=C1 S->N FA1 UA UC R2 (member?/out T-/>N) _
	(restrict/out A1|T=F T-/>N FA1 UA) F|S=E
    <- restrict-preserves-fresh FA1 A1|S=C1 FC1
    <- restrict/out-inversion R2 T-/>N FC1 UC C1|T=E
    <- restrict-reorders A1|S=C1 C1|T=E _ A1|T=F F|S=E.

- : restrict-reorders/in A1|S=C1 S->N FA1 UA UC R2 (member?/in T->N) _
	(restrict/in A1|T=F1 T->N FA1 UA UF)
	(restrict/in F1|S=E1 S->N FF1 UF UE)
    <- restrict-preserves-fresh FA1 A1|S=C1 FC1
    <- restrict/in-inversion R2 T->N FC1 UC _ C1|T=E1 UE
    <- restrict-reorders A1|S=C1 C1|T=E1 _ A1|T=F1 F1|S=E1
    <- update-total UF
    <- restrict-preserves-fresh FA1 A1|T=F1 FF1.
       
- : restrict-reorders
	(restrict/in A1|S=C1 S->N FA1 UA UC) C|T=E _ R3 R4
     <- member?-total M?
     <- restrict-reorders/in A1|S=C1 S->N FA1 UA UC C|T=E M? _ R3 R4.

%worlds () (restrict-reorders _ _ _ _ _)
	(restrict-reorders/in _ _ _ _ _ _ _ _ _ _).
%total (R1 R2) (restrict-reorders R1 _ _ _ _)
	(restrict-reorders/in R2 _ _ _ _ _ _ _ _ _).

%theorem restrict-reorders* :
	forall*	{A} {B} {C} {D} {E} {F}
	forall	{R1: restrict A B C}
		{R2: restrict C D E}
		{R3: restrict A D F}
	exists	{R4: restrict F B E}
	true.

- : restrict-reorders* R1 R2 R3 R4
    <- restrict-reorders R1 R2 _ R3P R4P
    <- restrict-unique R3P R3 eq/ set`eq/ FP=F
    <- restrict-respects-eq R4P FP=F set`eq/ eq/ R4.

%worlds () (restrict-reorders* _ _ _ _).
%total { } (restrict-reorders* _ _ _ _).


%theorem restrict-associates-intersection* :
	forall* {A} {C} {E} {S} {T} {V}
	forall	{R1: restrict A S C}
		{R2: restrict C T E}
		{I: intersection S T V}
	exists	{R3: restrict A V E}
	true.

- : restrict-associates-intersection* restrict/0 restrict/0 _ restrict/0.

- : restrict-associates-intersection*
	(restrict/out A1|S=C S-/>N FA1 UA) C|T=E I
	(restrict/out A1|V=E V-/>N FA1 UA)
    <- restrict-associates-intersection* A1|S=C C|T=E I A1|V=E
    <- intersection-right-preserves-not-member S-/>N I V-/>N.
	
%theorem restrict-associates-intersection*/L :
	forall* {A} {C} {E} {S} {T} {V} {B} {A1} {C1} {D} {N}
	forall	{R1: restrict A1 S C1}
		{M: member S N}
		{F1: fresh A1 N}
		{UA: update A1 N D A}
		{UC: update C1 N D C}
		{R2: restrict C T E}
		{I: intersection S T V}
		{M?: member? T N B}
	exists	{R3: restrict A V E}
	true.

- : restrict-associates-intersection*/L 
	A1|S=C1 S->N FA1 UA UC C|T=E I (member?/out T-/>N) 
	(restrict/out A1|V=E V-/>N FA1 UA)
    <- restrict-preserves-fresh FA1 A1|S=C1 FC1 
    <- restrict/out-inversion C|T=E T-/>N FC1 UC C1|T=E
    <- restrict-associates-intersection* A1|S=C1 C1|T=E I A1|V=E
    <- intersection-left-preserves-not-member T-/>N I V-/>N.

- : restrict-associates-intersection*/L 
	A1|S=C1 S->N FA1 UA UC C|T=E I (member?/in T->N) 
	(restrict/in A1|V=E1 V->N FA1 UA UE)
    <- restrict-preserves-fresh FA1 A1|S=C1 FC1 
    <- restrict/in-inversion C|T=E T->N FC1 UC _ C1|T=E1 UE
    <- restrict-associates-intersection* A1|S=C1 C1|T=E1 I A1|V=E1
    <- intersection-preserves-member S->N T->N I V->N.

- : restrict-associates-intersection*
	(restrict/in A1|S=C1 S->N FA1 UA UC) C|T=E I R
    <- member?-total M?
    <- restrict-associates-intersection*/L A1|S=C1 S->N FA1 UA UC C|T=E I M? R.

%worlds () (restrict-associates-intersection* _ _ _ _)
	   (restrict-associates-intersection*/L _ _ _ _ _ _ _ _ _).
%total (R1 R2) (restrict-associates-intersection* R1 _ _ _)
	       (restrict-associates-intersection*/L R2 _ _ _ _ _ _ _ _).


%theorem restrict-associates-intersection :
	forall* {A} {C} {E} {S} {T}
	forall	{R1: restrict A S C}
		{R2: restrict C T E}
	exists	{V} {I: intersection S T V}
		{R3: restrict A V E}
	true.

- : restrict-associates-intersection R1 R2 _ I R3
    <- intersection-total I
    <- restrict-associates-intersection* R1 R2 I R3.

%worlds () (restrict-associates-intersection _ _ _ _ _).
%total { } (restrict-associates-intersection _ _ _ _ _).


%theorem restrict-associates-intersection-converse* :
	forall* {A} {E} {S} {T} {V} {C}
	forall	{R3: restrict A V E}
		{I: intersection S T V}
		{R1: restrict A S C}
	exists	{R2: restrict C T E}
	true.

- : restrict-associates-intersection-converse* R3 I R1 R2
    <- restrict-total R2P
    <- restrict-associates-intersection* R1 R2P I R3P
    <- restrict-unique R3P R3 eq/ set`eq/ NEQ
    <- restrict-respects-eq R2P eq/ set`eq/ NEQ R2.

%worlds () (restrict-associates-intersection-converse* _ _ _ _).
%total { } (restrict-associates-intersection-converse* _ _ _ _).


%theorem restrict-associates-intersection-converse :
	forall* {A} {E} {S} {T} {V}
	forall	{R3: restrict A V E}
		{I: intersection S T V}
	exists	{C}
		{R1: restrict A S C}
		{R2: restrict C T E}
	true.

- : restrict-associates-intersection-converse R3 I _ R1 R2
    <- restrict-total R1
    <- restrict-associates-intersection-converse* R3 I R1 R2.

%worlds () (restrict-associates-intersection-converse _ _ _ _ _).
%total { } (restrict-associates-intersection-converse _ _ _ _ _).


%theorem empty-restriction:
	forall*	{A}
	exists	{R: restrict A set`0 map/0}
	true.

%theorem empty-restriction/L:
	forall*	{A}
	forall	{N} {Z: size A N}
	exists	{R: restrict A set`0 map/0}
	true.

- : empty-restriction/L _ _ restrict/0.

- : empty-restriction/L _ ZP 
	(restrict/out R set`not-member/0 F U)
    <- lookup-implies-fresh-update (lookup/= nat`eq/) _ F U
    <- fresh-update-increases-size-converse ZP F U Z
    <- empty-restriction/L _ Z R.

%worlds () (empty-restriction/L _ _ _).
%total (N) (empty-restriction/L N _ _).

- : empty-restriction R
    <- size-total Z
    <- empty-restriction/L _ Z R.

%worlds () (empty-restriction _).
%total { } (empty-restriction _).


%theorem fresh-implies-unit-restriction-empty:
	forall*	{A} {N}
	forall	{F: fresh A N}
	exists	{R: restrict A (set/1 N) map/0}
	true.

%theorem fresh-implies-unit-restriction-empty/L:
	forall*	{A} {N}
	forall	{S} {PZ: size A S}
		{F: fresh A N}
	exists	{R: restrict A (set/1 N) map/0}
	true.

- : fresh-implies-unit-restriction-empty/L z size/0 fresh/0 restrict/0.

- : fresh-implies-unit-restriction-empty/L _ Z FA
	(restrict/out R NM F U)
    <- lookup-implies-fresh-update (lookup/= nat`eq/) _ F U
    <- fresh-update-increases-size-converse Z F U ZP
    <- update-preserves-fresh-converse FA U FP
    <- fresh-implies-unit-restriction-empty/L _ ZP FP R
    <- fresh-lookup-not-equal FA (lookup/= nat`eq/) NE
    <- ne-implies-unit-map-not-member NE NM.

%worlds () (fresh-implies-unit-restriction-empty/L _ _ _ _).
%total (S) (fresh-implies-unit-restriction-empty/L S _ _ _).

- : fresh-implies-unit-restriction-empty F R
    <- size-total Z
    <- fresh-implies-unit-restriction-empty/L _ Z F R.

%worlds () (fresh-implies-unit-restriction-empty _ _).
%total { } (fresh-implies-unit-restriction-empty _ _).


%theorem lookup-implies-unit-restriction:
	forall*	{A} {N} {D}
	forall	{L: lookup A N D}
	exists	{R: restrict A (set/1 N) (map/1 N D)}
	true.

- : lookup-implies-unit-restriction L 
	(restrict/in A1|N=0 member/1 FA1 UA update/0)
    <- lookup-implies-fresh-update L _ FA1 UA
    <- fresh-implies-unit-restriction-empty FA1 A1|N=0.

%worlds () (lookup-implies-unit-restriction _ _).
%total { } (lookup-implies-unit-restriction _ _).


%theorem fresh-update-implies-restrict :
	forall*	{A} {N} {D} {B}
	forall	{F: fresh A N}
		{U: update A N D B}
	exists	{R: restrict B (set/1 N) (map/+ N D map/0)}
	true.

- : fresh-update-implies-restrict A-/>N U
	(restrict/in R member/1 A-/>N U update/0)
    <- fresh-implies-unit-restriction-empty A-/>N R.

%worlds () (fresh-update-implies-restrict _ _ _).
%total { } (fresh-update-implies-restrict _ _ _).


%theorem restrict-idempotent :
	forall*	{A} {B} {C}
	forall	{R:restrict A B C}
	exists	{R:restrict C B C}
	true.

- : restrict-idempotent A|B=C C|B=C 
    <- restrict-total C|B=E
    <- intersection-idempotent B^B=B
    <- restrict-associates-intersection* A|B=C C|B=E B^B=B A|B=E
    <- restrict-unique A|B=E A|B=C eq/ set`eq/ E=C
    <- restrict-respects-eq C|B=E eq/ set`eq/ E=C C|B=C.

%worlds () (restrict-idempotent _ _).
%total { } (restrict-idempotent _ _).

%{%
#ifdef MAP_DOMAIN
%}%

%theorem restrict-implies-domain-leq* :
	forall* {A} {S} {C} {DC}
	forall	{R:restrict A S C}
		{D: domain C DC}
	exists	{L: set`leq DC S}
	true.

- : restrict-implies-domain-leq* restrict/0 domain/0 set`leq/0.

- : restrict-implies-domain-leq*
	(restrict/in R M F U UP) DC1 D1<=S
    <- domain-total DC
    <- restrict-implies-domain-leq* R DC D<=S
    <- update-commute-domain UP DC DC1 D+N=D1
    <- member-implies-add M S+N=S
    <- set`add-preserves-leq* D<=S D+N=D1 S+N=S D1<=S.

- : restrict-implies-domain-leq*
	(restrict/out R NM F U) DC D<=S
    <- restrict-implies-domain-leq* R DC D<=S.

%worlds () (restrict-implies-domain-leq* _ _ _).
%total (R) (restrict-implies-domain-leq* R _ _).


%theorem restrict-implies-domain-leq :
	forall* {A} {S} {C}
	forall	{R:restrict A S C}
	exists	{DC}
		{D: domain C DC}
		{L: set`leq DC S}
	true.

- : restrict-implies-domain-leq restrict/0 _ domain/0 set`leq/0.

- : restrict-implies-domain-leq
	(restrict/in R M F U UP) _ DC1 D1<=S
    <- restrict-implies-domain-leq R _ DC D<=S
    <- domain-total DC1
    <- update-commute-domain UP DC DC1 D+N=D1
    <- member-implies-add M S+N=S
    <- set`add-preserves-leq* D<=S D+N=D1 S+N=S D1<=S.

- : restrict-implies-domain-leq
	(restrict/out R NM F U) _ DC D<=S
    <- restrict-implies-domain-leq R _ DC D<=S.

%worlds () (restrict-implies-domain-leq _ _ _ _).
%total (R) (restrict-implies-domain-leq R _ _ _).


%theorem restrict-implies-domain-intersection* :
	forall* {A} {S} {C} {DC} {DA}
	forall	{R: restrict A S C}
		{D1: domain A DA}
		{D2: domain C DC}
	exists	{L: set`intersection DA S DC}
	true.

- : restrict-implies-domain-intersection* 
	restrict/0 domain/0 domain/0 intersection/L.

- : restrict-implies-domain-intersection*
	(restrict/in R M F UA UC) DAP DCP DAP^S=DCP
    <- domain-total DA
    <- domain-total DC
    <- restrict-implies-domain-intersection*  
	R DA DC DA^S=DC
    <- update-commute-domain UA DA DAP DA+N=DAP
    <- update-commute-domain UC DC DCP DC+N=DCP
    <- add-implies-unit-union DA+N=DAP DAUN=DAP
    <- add-implies-unit-union DC+N=DCP DCUN=DCP
    <- set`member-implies-unit-leq M N<=S
    <- leq-implies-intersection N<=S N^S=N
    <- intersection-right-factors-over-union*
	DA^S=DC N^S=N
 	DCUN=DCP DAUN=DAP
	DAP^S=DCP.

- : restrict-implies-domain-intersection*
	(restrict/out R NM F U) DAP DC DAP^S=DC
    <- domain-total DA
    <- restrict-implies-domain-intersection* R DA DC DA^S=DC
    <- update-commute-domain U DA DAP DA+N=DAP
    <- add-implies-unit-union DA+N=DAP DAUN=DAP
    <- set`not-member-implies-unit-disjoint NM S^N
    <- set`disjoint-symmetric S^N N^S
    <- disjoint-intersection-empty N^S N^S=0
    <- intersection-right-factors-over-union*
	DA^S=DC N^S=0
 	union/R DAUN=DAP
	DAP^S=DC.
 
%worlds () (restrict-implies-domain-intersection* _ _ _ _).
%total (R) (restrict-implies-domain-intersection* R _ _ _).


%theorem domain-leq-implies-no-restriction:
	forall*	{A} {S} {D}
	forall	{X: domain A D}
		{L: set`leq D S}
	exists	{R: restrict A S A}
	true.

%theorem domain-leq-implies-no-restriction/L:
	forall*	{A} {S} {D}
	forall	{N}
		{Z: size A N}
		{X: domain A D}
		{L: set`leq D S}
	exists	{R: restrict A S A}
	true.

- : domain-leq-implies-no-restriction/L nat`z size/0 domain/0 _ restrict/0.

- : domain-leq-implies-no-restriction/L (s _) Z DA (DA<=S :set`leq DAX S)
	(restrict/in R1 M F U U)
    <- lookup-implies-fresh-update (lookup/= nat`eq/) _ F U
    <- domain-preserves-lookup (lookup/= nat`eq/) DA MA
    <- set`member-respects-leq MA DA<=S M
    <- fresh-update-increases-size-converse Z F U Z1
    <- domain-total DA1
    <- update-commute-domain U DA1 DA DA1+N=DA
    <- set`add-implies-leq DA1+N=DA DA1<=DA
    <- set`leq-transitive DA1<=DA DA<=S DA1<=S
    <- domain-leq-implies-no-restriction/L _ Z1 DA1 DA1<=S R1.

%worlds () (domain-leq-implies-no-restriction/L _ _ _ _ _).
%total (N) (domain-leq-implies-no-restriction/L N _ _ _ _).

- : domain-leq-implies-no-restriction DA DA<=S R
    <- size-total Z
    <- domain-leq-implies-no-restriction/L _ Z DA DA<=S R.

%worlds () (domain-leq-implies-no-restriction _ _ _).
%total { } (domain-leq-implies-no-restriction _ _ _).


%theorem domain-disjoint-implies-restrict-empty:
	forall*	{A} {S} {D}
	forall	{X: domain A D}
		{L: set`disjoint D S}
	exists	{R: restrict A S map/0}
	true.

%theorem domain-disjoint-implies-restrict-empty/L:
	forall*	{A} {S} {D}
	forall	{N}
		{Z: size A N}
		{X: domain A D}
		{L: set`disjoint D S}
	exists	{R: restrict A S map/0}
	true.

- : domain-disjoint-implies-restrict-empty/L nat`z _ domain/0 _ restrict/0.

- : domain-disjoint-implies-restrict-empty/L (s _) Z DA (DA^S :set`disjoint DAX S)
	(restrict/out R1 NM F U)
    <- lookup-implies-fresh-update (lookup/= nat`eq/) _ F U
    <- domain-preserves-lookup (lookup/= nat`eq/) DA MA
    <- disjoint-member-implies-not-member MA DA^S NM
    <- fresh-update-increases-size-converse Z F U Z1
    <- domain-total DA1
    <- update-commute-domain U DA1 DA DA1+N=DA
    <- set`add-implies-leq DA1+N=DA DA1<=DA
    <- set`disjoint-respects-geq* DA^S DA1<=DA DA1^S
    <- domain-disjoint-implies-restrict-empty/L _ Z1 DA1 DA1^S R1.

%worlds () (domain-disjoint-implies-restrict-empty/L _ _ _ _ _).
%total (N) (domain-disjoint-implies-restrict-empty/L N _ _ _ _).

- : domain-disjoint-implies-restrict-empty DA DJ R
    <- size-total Z
    <- domain-disjoint-implies-restrict-empty/L _ Z DA DJ R.

%worlds () (domain-disjoint-implies-restrict-empty _ _ _).
%total { } (domain-disjoint-implies-restrict-empty _ _ _).

%{%
#endif /* MAP_DOMAIN */
%}%

%{%
#ifdef MAP_LEQ
%}%

%theorem restrict-implies-leq :
	forall* {S1} {S2} {S3}
	forall {D:restrict S1 S2 S3}
	exists {L:leq S3 S1}
	true.

- : restrict-implies-leq restrict/0 leq/0.

- : restrict-implies-leq (restrict/out R _ F U) C<=A
    <- restrict-implies-leq R C<=A1
    <- fresh-update-implies-leq F U A1<=A
    <- leq-transitive C<=A1 A1<=A C<=A.

- : restrict-implies-leq (restrict/in R _ F U UP) C<=A
    <- restrict-implies-leq R C1<=A1
    <- update-left-preserves-leq* C1<=A1 UP U C<=A.

%worlds () (restrict-implies-leq _ _).
%total (R) (restrict-implies-leq R _).


%theorem restrict-right-preserves-leq :
	forall*	{A} {B} {C} {D} {E}
	forall	{L: leq A D}
		{R: restrict A B C}
		{RP: restrict D B E}
	exists	{LP: leq C E}
	true.

- : restrict-right-preserves-leq leq/0 restrict/0 _ leq/0.

- : restrict-right-preserves-leq A<=D 
	(restrict/out A1|B=C B-/>N FA1 UA) D|B=E C<=E
    <- update-implies-lookup UA LA
    <- lookup-respects-leq LA A<=D _ LD _
    <- lookup-implies-fresh-update LD _ FD1 UD
    <- restrict/out-inversion D|B=E B-/>N FD1 UD D1|B=E
    <- fresh-update-preserves-leq-converse A<=D FA1 UA FD1 UD A1<=D1 _
    <- restrict-right-preserves-leq A1<=D1 A1|B=C D1|B=E C<=E.

- : restrict-right-preserves-leq A<=D 
	(restrict/in A1|B=C1 B->N FA1 UA UC) D|B=E C<=E
    <- update-implies-lookup UA LA
    <- lookup-respects-leq LA A<=D _ LD _
    <- lookup-implies-fresh-update LD _ FD1 UD
    <- restrict/in-inversion D|B=E B->N FD1 UD _ D1|B=E1 UE
    <- fresh-update-preserves-leq-converse A<=D FA1 UA FD1 UD A1<=D1 LE
    <- restrict-right-preserves-leq A1<=D1 A1|B=C1 D1|B=E1 C1<=E1
    <- update-preserves-leq* C1<=E1 LE UC UE C<=E.

%worlds () (restrict-right-preserves-leq _ _ _ _).
%total (R) (restrict-right-preserves-leq _ R _ _).


%theorem restrict-left-preserves-leq :
        forall* {A} {B} {C} {D} {E}
        forall  {L: set`leq B D}
                {R1: restrict A B C}
                {R2: restrict A D E}
        exists  {LP: leq C E}
        true.

- : restrict-left-preserves-leq S<=T A|S=C A|T=E C<=E
    <- restrict-total E|S=G
    <- leq-implies-intersection S<=T S^T=S
    <- intersection-commutative S^T=S T^S=S
    <- restrict-associates-intersection* A|T=E E|S=G T^S=S A|S=G
    <- restrict-unique A|S=G A|S=C eq/ set`eq/ G=C
    <- restrict-respects-eq E|S=G eq/ set`eq/ G=C E|S=C
    <- restrict-implies-leq E|S=C C<=E.

%worlds () (restrict-left-preserves-leq _ _ _ _).
%total { } (restrict-left-preserves-leq _ _ _ _).

%{%
#endif /* MAP_LEQ */
%}%

%{%
#ifdef MAP_JOIN
#ifdef DATA_JOIN_ASSOCIATIVE
%}%

%theorem restrict-associates-disjoint-union* :
	forall*	{A} {C} {E} {G} {S} {T} {U}
	forall	{R1: restrict A S C}
		{R2: restrict A T E}
		{D: set`disjoint S T}
		{U1: union S T U}
		{J2: join C E G}
	exists	{R3: restrict A U G}
	true.

- : restrict-associates-disjoint-union* restrict/0 restrict/0 _ _ J restrict/0.

- : restrict-associates-disjoint-union*
	(restrict/in A1|S=C1 S->N FA1 UA UC) A|T=E S^T SUT=U CUE=G
        (restrict/in A1|U=G1 U->N FA1 UA UG)
    <- disjoint-member-implies-not-member S->N S^T T-/>N
    <- restrict/out-inversion A|T=E T-/>N FA1 UA A1|T=E
    <- restrict-left-preserves-disjoint S^T A1|S=C1 A1|T=E C1^E
    <- restrict-preserves-fresh FA1 A1|S=C1 FC1
    <- fresh-update-implies-unit-join FC1 UC C1UN=C
    <- disjoint-join-total C1^E _ C1UE=G1
    <- restrict-preserves-fresh FA1 A1|T=E FE
    <- fresh-implies-unit-disjoint FC1 C1^N
    <- disjoint-join-commutative C1^N C1UN=C NUC1=C
    <- join-associative* NUC1=C CUE=G C1UE=G1 NUG1=G
    <- join-preserves-fresh* FC1 FE C1UE=G1 FG1
    <- fresh-implies-unit-disjoint FG1 G1^N
    <- disjoint-symmetric G1^N N^G1
    <- disjoint-join-commutative N^G1 NUG1=G G1UN=G
    <- restrict-associates-disjoint-union* 
	A1|S=C1 A1|T=E S^T SUT=U C1UE=G1 A1|U=G1
    <- fresh-unit-join-implies-update FG1 G1UN=G UG
    <- union-right-preserves-member* S->N SUT=U U->N.

%theorem restrict-associates-disjoint-union*/L :
	forall*	{A} {C} {E} {G} {S} {T} {U} {A1} {N} {D} {B}
	forall	{R1: restrict A1 S C}
		{NM: not-member S N}
		{FA1: fresh A1 N}
		{UA: update A1 N D A}
		{R2: restrict A T E}
		{D: set`disjoint S T}
		{U1: union S T U}
		{J2: join C E G}
		{M?: member? T N B}
	exists	{R3: restrict A U G}
	true.

- : restrict-associates-disjoint-union*/L
	A1|S=C S-/>N FA1 UA A|T=E S^T SUT=U CUE=G (member?/in T->N)
        (restrict/in A1|U=G1 U->N FA1 UA UG)
    <- restrict/in-inversion A|T=E T->N FA1 UA _ A1|T=E1 UE
    <- restrict-left-preserves-disjoint S^T A1|S=C A1|T=E1 C^E1
    <- restrict-preserves-fresh FA1 A1|T=E1 FE1
    <- restrict-preserves-fresh FA1 A1|S=C FC
    <- fresh-update-implies-unit-join FE1 UE E1UN=E
    <- fresh-implies-unit-disjoint FE1 E1^N
    <- fresh-implies-unit-disjoint FC C^N
    <- join-right-preserves-disjoint* C^E1 C^N E1UN=E C^E
    <- disjoint-join-commutative C^E CUE=G EUC=G
    <- disjoint-join-commutative E1^N E1UN=E NUE1=E
    <- join-associative NUE1=E EUC=G G1 E1UC=G1 NUG1=G
    <- join-left-preserves-disjoint* E1^N C^N E1UC=G1 G1^N
    <- disjoint-symmetric G1^N N^G1
    <- disjoint-symmetric C^E1 E1^C
    <- disjoint-join-commutative N^G1 NUG1=G G1UN=G
    <- disjoint-join-commutative E1^C E1UC=G1 CUE1=G1
    <- restrict-associates-disjoint-union* 
	A1|S=C A1|T=E1 S^T SUT=U CUE1=G1 A1|U=G1
    <- restrict-preserves-fresh FA1 A1|U=G1 FG1
    <- fresh-unit-join-implies-update FG1 G1UN=G UG
    <- union-left-preserves-member* T->N SUT=U U->N.

- : restrict-associates-disjoint-union*/L
	A1|S=C S-/>N FA1 UA A|T=E S^T SUT=U CUE=G (member?/out T-/>N)
	(restrict/out A1|U=G U-/>N FA1 UA)
    <- restrict/out-inversion A|T=E T-/>N FA1 UA A1|T=E
    <- restrict-associates-disjoint-union* A1|S=C A1|T=E S^T SUT=U CUE=G A1|U=G
    <- union-preserves-not-member* S-/>N T-/>N SUT=U U-/>N.

- : restrict-associates-disjoint-union*
	(restrict/out A1|S=C S-/>N FA1 UA) A|T=E S^T SUT=U CUE=G R
    <- member?-total M?
    <- restrict-associates-disjoint-union*/L
	A1|S=C S-/>N FA1 UA A|T=E S^T SUT=U CUE=G M? R.

%worlds () (restrict-associates-disjoint-union* _ _ _ _ _ _)
	   (restrict-associates-disjoint-union*/L _ _ _ _ _ _ _ _ _ _).
%total (R1 R2) (restrict-associates-disjoint-union* R1 _ _ _ _ _)
	       (restrict-associates-disjoint-union*/L R2 _ _ _ _ _ _ _ _ _).

%theorem restrict-associates-disjoint-union :
	forall*	{A} {C} {E} {S} {T} {U}
	forall	{R1: restrict A S C}
		{R2: restrict A T E}
		{D: set`disjoint S T}
		{U1: union S T U}
	exists	{G}	
		{J2: join C E G}
		{R3: restrict A U G}
	true.

- : restrict-associates-disjoint-union A|S=C A|T=E S^T SUT=U _ CUE=G A|U=G
    <- restrict-left-preserves-disjoint S^T A|S=C A|T=E C^E
    <- disjoint-join-total C^E _ CUE=G
    <- restrict-associates-disjoint-union* A|S=C A|T=E S^T SUT=U CUE=G A|U=G.

%worlds () (restrict-associates-disjoint-union _ _ _ _ _ _ _).
%total { } (restrict-associates-disjoint-union _ _ _ _ _ _ _).


%theorem restrict-associates-disjoint-union-converse* :
	forall*	{A} {C} {E} {G} {S} {T} {U}
	forall	{R1: restrict A S C}
		{R2: restrict A T E}
		{D: set`disjoint S T}
		{U1: union S T U}
		{R3: restrict A U G}
	exists	{J2: join C E G}
	true.

- : restrict-associates-disjoint-union-converse*
	A|S=C A|T=E S^T SUT=V A|U=G CUE=G
    <- restrict-left-preserves-disjoint S^T A|S=C A|T=E C^E
    <- disjoint-join-total C^E GP CUE=GP
    <- restrict-associates-disjoint-union* A|S=C A|T=E S^T SUT=V CUE=GP A|U=GP
    <- restrict-unique A|U=GP A|U=G eq/ set`eq/ GP=G
    <- join-respects-eq CUE=GP eq/ eq/ GP=G CUE=G.

%worlds () (restrict-associates-disjoint-union-converse* _ _ _ _ _ _).
%total { } (restrict-associates-disjoint-union-converse* _ _ _ _ _ _).


%theorem restrict-left-preserves-disjoint-union:
	forall*	{A} {C} {E} {G} {S} {T} {U}
	forall	{D: set`disjoint S T}
		{U1: union S T U}
		{R1: restrict A S C}
		{R2: restrict A T E}
		{R3: restrict A U G}
	exists	{D2: disjoint C E}
		{J2: join C E G}
	true.

- : restrict-left-preserves-disjoint-union S^T SUT=V A|S=C A|T=E A|U=G C^E CUE=G
    <- restrict-left-preserves-disjoint S^T A|S=C A|T=E C^E
    <- restrict-associates-disjoint-union-converse* 
	A|S=C A|T=E S^T SUT=V A|U=G CUE=G.

%worlds () (restrict-left-preserves-disjoint-union _ _ _ _ _ _ _).
%total { } (restrict-left-preserves-disjoint-union _ _ _ _ _ _ _).


%theorem restrict-associates-join* :
	forall*	{A} {C} {D} {F} {G} {I} {S}
	forall	{R1: restrict A S C}
		{R2: restrict D S F}
		{U1: join A D G}
		{J2: join C F I}
	exists	{R3: restrict G S I}
	true.

- : restrict-associates-join* restrict/0 D|S=F ZUD=G ZUF=I G|S=I
    <- join-unique join/L ZUD=G eq/ eq/ D=G
    <- join-unique join/L ZUF=I eq/ eq/ F=I
    <- restrict-respects-eq D|S=F D=G set`eq/ F=I G|S=I.

%theorem restrict-associates-join*/in :
	forall*	{A} {C} {D} {F} {G} {I} {S} {A1} {C1} {N} {X} {B}
	forall	{R1: restrict A1 S C1}
		{M: member S N}
		{FA1: fresh A1 N}
		{UA1: update A1 N X A}
		{UC1: update C1 N X C}
		{R2: restrict D S F}
		{U1: join A D G}
		{J2: join C F I}
		{D?: domain? D N B}
	exists	{R3: restrict G S I}
	true.

- : restrict-associates-join*/in A1|S=C1 S->N FA1 UA UC D|S=F AUD=G CUF=I 
	(domain?/in DL)
	(restrict/in G1|S=I1 S->N FG1 UG UI)
    <- lookup-implies-fresh-update DL _ FD1 UD
    <- restrict/in-inversion D|S=F S->N FD1 UD _ D1|S=F1 UF
    <- restrict-preserves-fresh FA1 A1|S=C1 FC1
    <- restrict-preserves-fresh FD1 D1|S=F1 FF1
    <- fresh-update-implies-unit-join FA1 UA A1UP=A
    <- fresh-update-implies-unit-join FC1 UC C1UP=C
    <- fresh-update-implies-unit-join FD1 UD D1UQ=D
    <- fresh-update-implies-unit-join FF1 UF F1UQ=F
    %% workaround so that we do not require join to be commutative
    %{%
    <- join-double-associative A1UP=A D1UQ=D AUD=G _ _ A1UD1=G1 PUQ=R G1UR=G
    %}%
    <- fresh-implies-unit-disjoint FD1 D1^P
    <- fresh-implies-unit-disjoint FD1 D1^Q
    <- disjoint-join-commutative D1^Q D1UQ=D QUD1=D
    <- join-associative A1UP=A AUD=G DX PUD=DX A1UDX=G
    <- join-associative-converse QUD1=D PUD=DX R PUQ=R RUD1=DX
    <- join-right-preserves-disjoint* D1^P D1^Q PUQ=R D1^R
    <- disjoint-symmetric D1^R R^D1
    <- disjoint-join-commutative R^D1 RUD1=DX D1UR=DX
    <- join-associative-converse D1UR=DX A1UDX=G G1 A1UD1=G1 G1UR=G
    %{%
    <- join-double-associative C1UP=C F1UQ=F CUF=I _ _ C1UF1=I1 PUQ=RP I1URP=I
    %}%
    <- fresh-implies-unit-disjoint FF1 F1^P
    <- fresh-implies-unit-disjoint FF1 F1^Q
    <- disjoint-join-commutative F1^Q F1UQ=F QUF1=F
    <- join-associative C1UP=C CUF=I FX PUF=FX C1UFX=I
    <- join-associative-converse* QUF1=F PUF=FX PUQ=R RUF1=FX
    <- join-right-preserves-disjoint* F1^P F1^Q PUQ=R F1^R
    <- disjoint-symmetric F1^R R^F1
    <- disjoint-join-commutative R^F1 RUF1=FX F1UR=FX
    <- join-associative-converse F1UR=FX C1UFX=I I1 C1UF1=I1 I1UR=I
    %% done
    <- join/=-inversion PUQ=R nat`eq/ XG ZP XAUXD=XG ZUZ=ZP R=XGZP
    <- join-unique ZUZ=ZP join/L eq/ eq/ ZP=Z
    <- map/+-preserves-eq nat`eq/ data`eq/ ZP=Z XGZP=UXG
    <- eq-transitive R=XGZP XGZP=UXG R=UXG
    <- join-respects-eq G1UR=G eq/ R=UXG eq/ G1UXG=G
    <- join-respects-eq I1UR=I eq/ R=UXG eq/ I1UXG=I
    <- join-preserves-fresh* FA1 FD1 A1UD1=G1 FG1
    <- join-preserves-fresh* FC1 FF1 C1UF1=I1 FI1
    <- fresh-unit-join-implies-update FG1 G1UXG=G UG
    <- fresh-unit-join-implies-update FI1 I1UXG=I UI
    <- restrict-associates-join* A1|S=C1 D1|S=F1 A1UD1=G1 C1UF1=I1 G1|S=I1.

- : restrict-associates-join*/in A1|S=C1 S->N FA1 UA UC D|S=F AUD=G CUF=I 
	(domain?/out FD)
	(restrict/in G1|S=I1 S->N FG1 UG UI)
    <- restrict-preserves-fresh FA1 A1|S=C1 FC1
    <- restrict-preserves-fresh FD D|S=F FF
    <- fresh-update-implies-unit-join FA1 UA A1UP=A
    <- fresh-update-implies-unit-join FC1 UC C1UP=C
    %{%
    <- join-assoc-commutative A1UP=A AUD=G G1 A1UD=G1 G1UP=G
    <- join-assoc-commutative C1UP=C CUF=I I1 C1UF=I1 I1UP=I
    %}%
    <- fresh-implies-unit-disjoint FD D^P
    <- fresh-implies-unit-disjoint FF F^P
    <- join-associative A1UP=A AUD=G DX PUD=DX A1UDX=G
    <- join-associative C1UP=C CUF=I FX PUF=FX C1UFX=I
    <- disjoint-symmetric D^P P^D
    <- disjoint-symmetric F^P P^F
    <- disjoint-join-commutative P^D PUD=DX DUP=DX
    <- disjoint-join-commutative P^F PUF=FX FUP=FX
    <- join-associative-converse DUP=DX A1UDX=G G1 A1UD=G1 G1UP=G
    <- join-associative-converse FUP=FX C1UFX=I I1 C1UF=I1 I1UP=I
    <- join-preserves-fresh* FA1 FD A1UD=G1 FG1
    <- join-preserves-fresh* FC1 FF C1UF=I1 FI1
    <- fresh-unit-join-implies-update FG1 G1UP=G UG
    <- fresh-unit-join-implies-update FI1 I1UP=I UI
    <- restrict-associates-join* A1|S=C1 D|S=F A1UD=G1 C1UF=I1 G1|S=I1.

- : restrict-associates-join*
	(restrict/in A1|S=C1 S->N FA1 UA UC) D|S=F AUD=G CUF=I R
    <- domain?-total D?
    <- restrict-associates-join*/in 
	A1|S=C1 S->N FA1 UA UC  D|S=F AUD=G CUF=I D? R.

%theorem restrict-associates-join*/out :
	forall*	{A} {C} {D} {F} {G} {I} {S} {A1} {N} {X} {B}
	forall	{R1: restrict A1 S C}
		{NM: not-member S N}
		{FA1: fresh A1 N}
		{UA1: update A1 N X A}
		{R2: restrict D S F}
		{U1: join A D G}
		{J2: join C F I}
		{D?: domain? D N B}
	exists	{R3: restrict G S I}
	true.

- : restrict-associates-join*/out A1|S=C S-/>N FA1 UA D|S=F AUD=G CUF=I 
	(domain?/in DL)
	(restrict/out G1|S=I S-/>N FG1 UG)
    <- lookup-implies-fresh-update DL _ FD1 UD
    <- restrict/out-inversion D|S=F S-/>N FD1 UD D1|S=F
    <- fresh-update-implies-unit-join FA1 UA A1UP=A
    <- fresh-update-implies-unit-join FD1 UD D1UQ=D
    %% <- join-double-associative A1UP=A D1UQ=D AUD=G _ _ A1UD1=G1 PUQ=R G1UR=G
    <- fresh-implies-unit-disjoint FD1 D1^P
    <- fresh-implies-unit-disjoint FD1 D1^Q
    <- disjoint-join-commutative D1^Q D1UQ=D QUD1=D
    <- join-associative A1UP=A AUD=G DX PUD=DX A1UDX=G
    <- join-associative-converse QUD1=D PUD=DX R PUQ=R RUD1=DX
    <- join-right-preserves-disjoint* D1^P D1^Q PUQ=R D1^R
    <- disjoint-symmetric D1^R R^D1
    <- disjoint-join-commutative R^D1 RUD1=DX D1UR=DX
    <- join-associative-converse D1UR=DX A1UDX=G G1 A1UD1=G1 G1UR=G
    <- join/=-inversion PUQ=R nat`eq/ XG ZP XAUXD=XG ZUZ=ZP R=XGZP
    <- join-unique ZUZ=ZP join/L eq/ eq/ ZP=Z
    <- map/+-preserves-eq nat`eq/ data`eq/ ZP=Z XGZP=UXG
    <- eq-transitive R=XGZP XGZP=UXG R=UXG
    <- join-respects-eq G1UR=G eq/ R=UXG eq/ G1UXG=G
    <- join-preserves-fresh* FA1 FD1 A1UD1=G1 FG1
    <- fresh-unit-join-implies-update FG1 G1UXG=G UG
    <- restrict-associates-join* A1|S=C D1|S=F A1UD1=G1 CUF=I G1|S=I.

- : restrict-associates-join*/out A1|S=C S-/>N FA1 UA D|S=F AUD=G CUF=I 
	(domain?/out FD)
	(restrict/out G1|S=I S-/>N FG1 UG)
    <- restrict-preserves-fresh FA1 A1|S=C FC
    <- restrict-preserves-fresh FD D|S=F FF
    <- fresh-update-implies-unit-join FA1 UA A1UP=A
    %% <- join-assoc-commutative A1UP=A AUD=G G1 A1UD=G1 G1UP=G
    <- fresh-implies-unit-disjoint FD D^P
    <- join-associative A1UP=A AUD=G DX PUD=DX A1UDX=G
    <- disjoint-symmetric D^P P^D
    <- disjoint-join-commutative P^D PUD=DX DUP=DX
    <- join-associative-converse DUP=DX A1UDX=G G1 A1UD=G1 G1UP=G
    <- join-preserves-fresh* FA1 FD A1UD=G1 FG1
    <- fresh-unit-join-implies-update FG1 G1UP=G UG
    <- restrict-associates-join* A1|S=C D|S=F A1UD=G1 CUF=I G1|S=I.

- : restrict-associates-join*
	(restrict/out A1|S=C S-/>N FA1 UA) D|S=F AUD=G CUF=I R
    <- domain?-total D?
    <- restrict-associates-join*/out A1|S=C S-/>N FA1 UA D|S=F AUD=G CUF=I D? R.

%worlds () (restrict-associates-join* _ _ _ _ _)
           (restrict-associates-join*/in _ _ _ _ _ _ _ _ _ _)
           (restrict-associates-join*/out _ _ _ _ _ _ _ _ _).
%total (R1 R2 R3) (restrict-associates-join* R1 _ _ _ _)
                  (restrict-associates-join*/in R2 _ _ _ _ _ _ _ _ _)
                  (restrict-associates-join*/out R3 _ _ _ _ _ _ _ _).

%{%
#ifdef DATA_JOIN_TOTAL_STAR
%}%

%theorem restrict-associates-join :
	forall*	{A} {C} {D} {F} {G} {S}
	forall	{R1: restrict A S C}
		{R2: restrict D S F}
		{U1: join A D G}
	exists	{I}
		{J2: join C F I}
		{R3: restrict G S I}
	true.

- : restrict-associates-join R1 R2 J1 _ J2 R3
    <- join-total J2
    <- restrict-associates-join* R1 R2 J1 J2 R3.

%worlds () (restrict-associates-join _ _ _ _ _ _).
%total { } (restrict-associates-join _ _ _ _ _ _).


%theorem join-commute-restrict* :
	forall*	{M1} {M2} {M3} {S} {M1P} {M2P} {M3P}
	forall	{J: join M1 M2 M3}
		{R1: restrict M1 S M1P}
		{R2: restrict M2 S M2P}
		{R3: restrict M3 S M3P}
	exists	{J: join M1P M2P M3P}
	true.

%abbrev restrict-right-preserves-join = join-commute-restrict*.

- : join-commute-restrict* J1 R1 R2 R3 J2
    <- restrict-associates-join R1 R2 J1 _ J2P R3P
    <- restrict-unique R3P R3 eq/ set`eq/ MP=M
    <- join-respects-eq J2P eq/ eq/ MP=M J2.
    
%worlds () (join-commute-restrict* _ _ _ _ _).
%total { } (join-commute-restrict* _ _ _ _ _).
% NB: converse is not true or else AUB=C for all A,B,C (think S=0)

%{%
#endif
%}%

%theorem restrict-associates-disjoint-union-converse :
	forall*	{A} {S} {T} {V} {G}
	forall	{D: set`disjoint S T}
		{U: union S T V}
		{R3: restrict A V G}
	exists	{C} {E}
		{R1: restrict A S C}
		{R2: restrict A T E}
		{D: disjoint C E}
		{J: join C E G}
	true.

- : restrict-associates-disjoint-union-converse S^T SUT=V A|V=G C E
	A|S=C A|T=E C^E CUE=G
    <- restrict-total A|S=C 
    <- restrict-total A|T=E
    <- restrict-left-preserves-disjoint-union S^T SUT=V A|S=C A|T=E A|V=G
	C^E CUE=G.

%worlds () (restrict-associates-disjoint-union-converse _ _ _ _ _ _ _ _ _).
%total { } (restrict-associates-disjoint-union-converse _ _ _ _ _ _ _ _ _).


%theorem restrict-implies-disjoint-join:
	forall*	{A} {C} {S}
	forall	{R: restrict A S C}
	exists	{B}
		{D: disjoint B C}
		{J: join B C A}
	true.

- : restrict-implies-disjoint-join restrict/0 _ disjoint/L join/L.

- : restrict-implies-disjoint-join 
	(restrict/out A1|S=C S-/>N FA1 UA) _ B^C BUC=A
    <- restrict-implies-disjoint-join A1|S=C B1 B1^C B1UC=A1
    <- join-preserves-fresh-converse* FA1 B1UC=A1 FB1 FC
    <- fresh-update-implies-unit-join FA1 UA A1UX=A
    <- update-total UB
    <- disjoint-symmetric B1^C C^B1
    <- fresh-update-preserves-disjoint C^B1 FC UB C^B
    <- disjoint-symmetric C^B B^C
    <- fresh-update-implies-unit-join FB1 UB B1UX=B
    <- disjoint-join-commutative B1^C B1UC=A1 CUB1=A1
    <- join-associative* CUB1=A1 A1UX=A B1UX=B CUB=A
    <- disjoint-join-commutative C^B CUB=A BUC=A.

- : restrict-implies-disjoint-join 
	(restrict/in A1|S=C1 S->N FA1 UA UC) _ B^C BUC=A
    <- restrict-implies-disjoint-join A1|S=C1 B B^C1 BUC1=A1
    <- join-preserves-fresh-converse* FA1 BUC1=A1 FB FC1
    <- fresh-update-implies-unit-join FA1 UA A1UX=A
    <- fresh-update-implies-unit-join FC1 UC C1UX=C
    <- fresh-update-preserves-disjoint B^C1 FB UC B^C
    <- join-associative* BUC1=A1 A1UX=A C1UX=C BUC=A.

%worlds () (restrict-implies-disjoint-join _ _ _ _).
%total (R) (restrict-implies-disjoint-join R _ _ _).

%{%
#endif /* DATA_JOIN_ASSOCIATIVE */
/* as well as join, we also can have ... */
#ifdef MAP_DOMAIN
%}%

%theorem restrict-characterization:
	forall*	{A} {B} {C} {DB} {DC} {S}
	forall	{J1: join C B A}
		{D2: domain C DC}
		{L3: set`leq DC S}
		{D4: domain B DB}
		{D5: set`disjoint DB S}
	exists	{R: restrict A S C}
	true.

%theorem restrict-characterization/L:
	forall*	{A} {B} {C} {DB} {DC} {S}
	forall	{N}
		{Z: size A N}
		{J1: join C B A}
		{D2: domain C DC}
		{L3: set`leq DC S}
		{D4: domain B DB}
		{D5: set`disjoint DB S}
	exists	{R: restrict A S C}
	true.

- : restrict-characterization/L _ _ join/L _ _ D D^S R
    <- domain-disjoint-implies-restrict-empty D D^S R.

- : restrict-characterization/L _ _ join/R D D<=S _ _ R
    <- domain-leq-implies-no-restriction D D<=S R.

- : restrict-characterization/L (s _) _ (join/= _ _ nat`eq/) DC DC<=S DB DB^S R
    <- domain-preserves-lookup (lookup/= nat`eq/) DC DC->N
    <- domain-preserves-lookup (lookup/= nat`eq/) DB DB->N
    <- set`disjoint-symmetric DB^S S^DB
    <- set`disjoint-respects-geq* S^DB DC<=S DC^DB
    <- set`disjoint-member-contradiction DC^DB DC->N DB->N F
    <- false-implies-restrict F R.

- : restrict-characterization/L (s _) ZP (join/< J1 P) DC DC<=S DB DB^S
	(restrict/in A1|S=C1 S->N FA1 UA UC)
    <- domain-preserves-lookup (lookup/= nat`eq/) DC DC->N
    <- member-respects-leq DC->N DC<=S S->N
    <- shift-total SHA
    <- shift-total SHC
    <- shift-implies-fresh SHA FA1
    <- shift-implies-fresh SHC FC1
    <- shift-implies-update SHA UA
    <- shift-implies-update SHC UC
    <- fresh-update-increases-size-converse ZP FA1 UA Z
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- shift-preserves-join* J1 SHC (shift/+ Psc) SHA J
    <- domain-total DC1
    <- update-commute-domain UC DC1 DC DC1+N=DC
    <- set`add-implies-leq DC1+N=DC DC1<=DC
    <- set`leq-transitive DC1<=DC DC<=S DC1<=S
    <- restrict-characterization/L _ Z J DC1 DC1<=S DB DB^S A1|S=C1.

- : restrict-characterization/L (s _) ZP (join/> J1 P) DC DC<=S DB DB^S
	(restrict/out A1|S=C S-/>N FA1 UA)
    <- domain-preserves-lookup (lookup/= nat`eq/) DB DB->N
    <- disjoint-member-implies-not-member DB->N DB^S S-/>N
    <- shift-total SHA
    <- shift-total SHB
    <- shift-implies-fresh SHA FA1
    <- shift-implies-update SHA UA
    <- shift-implies-update SHB UB
    <- fresh-update-increases-size-converse ZP FA1 UA Z
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- shift-preserves-join* J1 (shift/+ Psc) SHB SHA J
    <- domain-total DB1
    <- update-commute-domain UB DB1 DB DB1+N=DB
    <- set`add-implies-leq DB1+N=DB DB1<=DB
    <- set`disjoint-respects-geq* DB^S DB1<=DB DB1^S
    <- restrict-characterization/L _ Z J DC DC<=S DB1 DB1^S A1|S=C.

%worlds () (restrict-characterization/L _ _ _ _ _ _ _ _).
%total (N) (restrict-characterization/L N _ _ _ _ _ _ _).

- : restrict-characterization CUB=A DC DC<=S DB DB^S R
    <- size-total Z
    <- restrict-characterization/L _ Z CUB=A DC DC<=S DB DB^S R.

%worlds () (restrict-characterization _ _ _ _ _ _).
%total { } (restrict-characterization _ _ _ _ _ _).

%{%
#endif /* MAP_DOMAIN */
#endif /* MAP_JOIN */
#ifdef MAP_SCALE
%}%

%theorem scale-commutes-restrict:
	forall*	{V} {S} {M1} {M2} {M4}
	forall	{SC: scale V M1 M2}
		{MR: restrict M2 S M4}
	exists	{M3}
		{MR: restrict M1 S M3}
		{SC: scale V M3 M4}
	true.

- : scale-commutes-restrict scale/0 restrict/0 _ restrict/0 scale/0.

- : scale-commutes-restrict S1P
	(restrict/out R2 NM F2 U2) _
	(restrict/out R1 NM F1 U1) S3
    <- fresh-update-commutes-inv-scale F2 U2 S1P _ _ S1 DS U1
    <- scale-commutes-restrict S1 R2 _ R1 S3
    <- scale-preserves-fresh-converse F2 S1 F1.

- : scale-commutes-restrict S1P
	(restrict/in R2 M F2 U2 U3) _
	(restrict/in R1 M F1 U1 U4) S3P
    <- fresh-update-commutes-inv-scale F2 U2 S1P _ _ S1 DS U1
    <- scale-commutes-restrict S1 R2 _ R1 S3
    <- scale-preserves-fresh-converse F2 S1 F1
    <- scale-commutes-update S3 U3 DS _ U4 S3P.

%worlds () (scale-commutes-restrict _ _ _ _ _).
%total (R) (scale-commutes-restrict _ R _ _ _).


%theorem scale-commutes-restrict*:
	forall*	{V} {S} {M1} {M2} {M3} {M4}
	forall	{SC: scale V M1 M2}
		{MR: restrict M2 S M4}
		{MR: restrict M1 S M3}
	exists	{SC: scale V M3 M4}
	true.

- : scale-commutes-restrict* S1 R2 R1 S2
    <- scale-commutes-restrict S1 R2 _ R1P S2P
    <- restrict-unique R1P R1 eq/ set`eq/ M3P=M3
    <- scale-respects-eq S2P scalar`eq/ M3P=M3 eq/ S2.

%worlds () (scale-commutes-restrict* _ _ _ _).
%total { } (scale-commutes-restrict* _ _ _ _).


%theorem restrict-commutes-scale*:
	forall*	{V} {S} {M1} {M2} {M3} {M4}
	forall	{MR: restrict M1 S M3}
		{SC: scale V M3 M4}
		{SC: scale V M1 M2}
	exists	{MR: restrict M2 S M4}
	true.

- : restrict-commutes-scale* R1 S3 S1 R2
    <- restrict-total R2P
    <- scale-commutes-restrict* S1 R2P R1 S3P
    <- scale-unique S3P S3 scalar`eq/ eq/ M4P=M4
    <- restrict-respects-eq R2P eq/ set`eq/ M4P=M4 R2.

%worlds () (restrict-commutes-scale* _ _ _ _).
%total { } (restrict-commutes-scale* _ _ _ _).


%theorem restrict-commutes-scale:
	forall*	{V} {S} {M1} {M3} {M4}
	forall	{MR: restrict M1 S M3}
		{SC: scale V M3 M4}
	exists	{M2}
		{SC: scale V M1 M2}
		{MR: restrict M2 S M4}
	true.

- : restrict-commutes-scale R1 S3 _ S1 R2
    <- scale-total S1
    <- restrict-commutes-scale* R1 S3 S1 R2.

%worlds () (restrict-commutes-scale _ _ _ _ _).
%total { } (restrict-commutes-scale _ _ _ _ _).

%{%
#endif /* MAP_SCALE */
%}%
