%{%
#ifdef DATA_JOIN_IMPLIES_LEQ
%}%

%theorem join-implies-leq* :
	forall* {M1} {M2} {M3}
	forall {J:join M1 M2 M3}
        exists {L:leq M1 M3}
	true.

- : join-implies-leq* join/L leq/0.

- : join-implies-leq* join/R M2=M2
    <- leq-reflexive _ M2=M2.

- : join-implies-leq* (join/= M1+M2=M3 D1+D2=D3 nat`eq/) 
                      (leq/= M1<=M3 D1<=D3 nat`eq/)
    <- data`join-implies-leq* D1+D2=D3 D1<=D3
    <- join-implies-leq* M1+M2=M3 M1<=M3.

- : join-implies-leq* (join/< M1+_=M3 _) (leq/= M1<=M3 D1<=D1 nat`eq/)
    <- data`leq-reflexive _ D1<=D1
    <- join-implies-leq* M1+_=M3 M1<=M3.	

- : join-implies-leq* (join/> M311+M2=M3 P) (leq/> M311<=M3 P)
    <- join-implies-leq* M311+M2=M3 M311<=M3.

%worlds () (join-implies-leq* _ _).
%total (J) (join-implies-leq* J _).

%{%
#ifdef DATA_JOIN_COMMUTATIVE
%}%

%theorem join-implies-leq :
	forall* {M1} {M2} {M3}
	forall {A:join M1 M2 M3}
        exists {L1:leq M1 M3} {L2:leq M2 M3}
	true.

- : join-implies-leq M1*M2=M3 M1<=M3 M2<=M3
    <- join-implies-leq* M1*M2=M3 M1<=M3
    <- join-commutative M1*M2=M3 M2*M1=M3
    <- join-implies-leq* M2*M1=M3 M2<=M3.

%worlds () (join-implies-leq _ _ _).
%total { } (join-implies-leq _ _ _).

%{%
#endif
#endif

#ifdef DATA_LEQ_NE_IMPLIES_JOIN
%}%

%theorem leq-implies-join :
	forall* {M1} {M2}
	forall {L:leq M1 M2}
	exists {M0} {A:join M0 M1 M2}
	true.

- : leq-implies-join leq/0 _ join/R.

% lemma for leq/= to test whether equal or not
%theorem leq-implies-join/= :
	forall* {M0} {M1} {M2} {N} {D1} {D2} {B}
	forall {A:join M0 M1 M2} {L:data`leq D1 D2} {E?:data`eq? D1 D2 B}
	exists {M000} {A:join M000 (map/+ N D1 M1) (map/+ N D2 M2)}
	true.

- : leq-implies-join (leq/= M1<=M2 D1<=D2 nat`eq/) _ A
    <- leq-implies-join M1<=M2 _ M0+M1=M2
    <- data`eq?-total D1?D2
    <- leq-implies-join/= M0+M1=M2 D1<=D2 D1?D2 _ A.

- : leq-implies-join/= M0+M1=M2 _ (data`eq?/yes) _ M0<<X+M1X+M2X
    <- shift-total S
    <- shift-left-preserves-join M0+M1=M2 S M0<<X+M1X+M2X.

- : leq-implies-join/= M0+M1=M2 D1<=D2 (data`eq?/no D1<>D2) _
                       (join/= M0+M1=M2 D0+D1=D2 nat`eq/)
    <- data`leq-ne-implies-join D1<=D2 D1<>D2 _ D0+D1=D2.

- : leq-implies-join (leq/> M311<=M2 N3+1+N2=N1) _
                     (join/< M0+M311=M2 N3+1+N2=N1)
    <- leq-implies-join M311<=M2 _ M0+M311=M2.

%worlds () (leq-implies-join/= _ _ _ _ _).
%total { } (leq-implies-join/= _ _ _ _ _).

%worlds () (leq-implies-join _ _ _).
%total (L) (leq-implies-join L _ _).
  
%{%
#define LEQ_IMPLIES_JOIN 1
#define CMP_IFF_OP 1
#endif /* DATA_LEQ_NE_IMPLIES_JOIN */

#ifdef DATA_JOIN_IS_LUB
%}%

%theorem join-is-lub :
	forall* {M1} {M2} {M3} {M4}
	forall {J:join M1 M2 M3}
	       {L1:leq M1 M4} {L2:leq M2 M4}
	exists {L3:leq M3 M4}
	true.

- : join-is-lub join/L _ L L.

- : join-is-lub join/R L _ L.

- : join-is-lub (join/= M1+M2=M3 D1+D2=D3 nat`eq/)
                (leq/= M1<=M4 D1<=D4 nat`eq/)
                (leq/= M2<=M4 D2<=D4 nat`eq/)
                (leq/= M3<=M4 D3<=D4 nat`eq/)
    <- data`join-is-lub D1+D2=D3 D1<=D4 D2<=D4 D3<=D4
    <- join-is-lub M1+M2=M3 M1<=M4 M2<=M4 M3<=M4.

- : join-is-lub (join/= _ _ nat`eq/) (leq/= _ _ nat`eq/) (leq/> _ N3+1+N=N) L
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-leq F L.

- : join-is-lub (join/= _ _ nat`eq/) (leq/> _ N3+1+N=N) (leq/= _ _ nat`eq/) L
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-leq F L.

- : join-is-lub (join/= M1+M2=M3 D1+D2=D3 nat`eq/)
                (leq/> M511<=M4 N5+1+N4=N)
                (leq/> M622<=M4 N6+1+N4=N)
                (leq/> M633<=M4 N6+1+N4=N)
    <- nat`plus-right-cancels N5+1+N4=N N6+1+N4=N nat`eq/ nat`eq/ N5+1=N6+1
    <- nat`succ-cancels N5+1=N6+1 N5=N6
    <- map/+-preserves-eq N5=N6 data`eq/ eq/ M511=M611
    <- leq-respects-eq M511<=M4 M511=M611 eq/ M611<=M4
    <- join-is-lub (join/= M1+M2=M3 D1+D2=D3 nat`eq/) 
                   M611<=M4 M622<=M4 M633<=M4.

- : join-is-lub (join/< _ N0+1+N=N) (leq/= _ _ nat`eq/) (leq/= _ _ nat`eq/) L
    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-leq F L.

- : join-is-lub (join/< M1+M022=M3 N0+1+N1=N2)
                (leq/= M1<=M4 D1<=D4 nat`eq/)
                (leq/> M622<=M4 N6+1+N1=N2)
                (leq/= M3<=M4 D1<=D4 nat`eq/)
    <- nat`plus-right-cancels N6+1+N1=N2 N0+1+N1=N2 nat`eq/ nat`eq/ N6+1=N0+1
    <- succ-cancels N6+1=N0+1 N6=N0
    <- map/+-preserves-eq N6=N0 data`eq/ eq/ M622=M022
    <- leq-respects-eq M622<=M4 M622=M022 eq/ M022<=M4
    <- join-is-lub M1+M022=M3 M1<=M4 M022<=M4 M3<=M4.

- : join-is-lub (join/< _ N0+1+N1=N2) (leq/> _ N3+1+N2=N1) (leq/= _ _ nat`eq/) L
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-leq F L.

- : join-is-lub (join/< M1+M022=M3 N0+1+N1=N2)
                (leq/> M511<=M4 N5+1+N4=N1)
                (leq/> M622<=M4 N6+1+N4=N2)
                (leq/> M513<=M4 N5+1+N4=N1)
    <- nat`plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- nat`plus-associative-converse N5+N4+1=N1 N0+1+N1=N2 
                                     N6' N0+1+N5=N6' N6'+N4+1=N2
    <- nat`plus-swap-succ-converse N6'+N4+1=N2 N6'+1+N4=N2
    <- nat`plus-right-cancels N6'+1+N4=N2 N6+1+N4=N2 nat`eq/ nat`eq/ N6'+1=N6+1
    <- nat`succ-cancels N6'+1=N6+1 N6'=N6
    <- nat`plus-respects-eq N0+1+N5=N6' nat`eq/ nat`eq/ N6'=N6 N0+1+N5=N6
    <- join-is-lub (join/< M1+M022=M3 N0+1+N5=N6) M511<=M4 M622<=M4 M513<=M4.

- : join-is-lub (join/> _ N3+1+N=N) (leq/= _ _ nat`eq/) (leq/= _ _ nat`eq/) L
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-leq F L.

- : join-is-lub (join/> _ N3+1+N2=N1) (leq/= _ _ nat`eq/) (leq/> _ N0+1+N1=N2) L
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-leq F L.

- : join-is-lub (join/> M311+M2=M3 N3+1+N2=N1)
                (leq/> M511<=M4 N5+1+N2=N1)
                (leq/= M2<=M4 D2<=D4 nat`eq/)
                (leq/= M3<=M4 D2<=D4 nat`eq/)
    <- nat`plus-right-cancels N3+1+N2=N1 N5+1+N2=N1 nat`eq/ nat`eq/ N3+1=N5+1
    <- nat`succ-cancels N3+1=N5+1 N3=N5
    <- map/+-preserves-eq N3=N5 data`eq/ eq/ M311=M511
    <- join-respects-eq M311+M2=M3 M311=M511 eq/ eq/ M511+M2=M3
    <- join-is-lub M511+M2=M3 M511<=M4 M2<=M4 M3<=M4.

- : join-is-lub (join/> M311+M2=M3 N3+1+N2=N1)
                (leq/> M511<=M4 N5+1+N4=N1)
                (leq/> M622<=M4 N6+1+N4=N2)
                (leq/> M623<=M4 N6+1+N4=N2)
    <- nat`plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- nat`plus-associative-converse N6+N4+1=N2 N3+1+N2=N1 
                                     N5' N3+1+N6=N5' N5'+N4+1=N1
    <- nat`plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- nat`plus-right-cancels N5'+N4+1=N1 N5+N4+1=N1 nat`eq/ nat`eq/ N5'=N5
    <- nat`plus-respects-eq N3+1+N6=N5' nat`eq/ nat`eq/ N5'=N5 N3+1+N6=N5
    <- join-is-lub (join/> M311+M2=M3 N3+1+N6=N5) M511<=M4 M622<=M4 M623<=M4.

%worlds () (join-is-lub _ _ _ _).
%total (L) (join-is-lub _ L _ _).


%theorem join-idempotent :
	forall* {S}
	exists {J:join S S S}
	true.

- : join-idempotent S+S=S
    <- join-total S+S=S'
    <- join-implies-leq* S+S=S' S<=S'
    <- leq-reflexive _ S<=S
    <- join-is-lub S+S=S' S<=S S<=S S'<=S
    <- leq-anti-symmetric S'<=S S<=S' S'=S
    <- join-respects-eq S+S=S' eq/ eq/ S'=S S+S=S.

%worlds () (join-idempotent _).
%total { } (join-idempotent _).


%theorem leq-implies-join :
	forall* {M1} {M2}
	forall {L:leq M1 M2}
	exists {J:join M1 M2 M2}
	true.

- : leq-implies-join M1<=M2 M1+M2=M2
    <- join-total M1+M2=M3
    <- leq-reflexive _ M2<=M2
    <- join-is-lub M1+M2=M3 M1<=M2 M2<=M2 M3<=M2
    <- join-implies-leq M1+M2=M3 _ M2<=M3
    <- leq-anti-symmetric M3<=M2 M2<=M3 M3=M2
    <- join-respects-eq M1+M2=M3 eq/ eq/ M3=M2 M1+M2=M2.

%worlds () (leq-implies-join _ _).
%total { } (leq-implies-join _ _).

%{%
#define LEQ_IMPLIES_JOIN 1
#endif /* DATA_JOIN_IS_LUB */


#ifdef DATA_JOIN_PRESERVES_LEQ
%}%

%theorem join-left-preserves-leq* :
	forall* {M1} {M2} {M3} {M4} {M5}
	forall {L1:leq M2 M4}
               {J:join M1 M2 M3} {JP:join M1 M4 M5}
	exists {L3:leq M3 M5}
	true.

- : join-left-preserves-leq* L join/L join/L L.

- : join-left-preserves-leq* _ join/L join/R leq/0.

- : join-left-preserves-leq* leq/0 join/R M1+M4=M5 M1<=M5
    <- join-implies-leq* M1+M4=M5 M1<=M5.

- : join-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/)
                             (join/= M1+M2=M3 D1+D2=D3 nat`eq/)
                             M111+M144=M M133<=M
    <- join/=-inversion M111+M144=M nat`eq/ D5 M5 D1+D4=D5 M1+M4=M5 M=M155
    <- eq-symmetric M=M155 M155=M
    <- meta-eq (map/+ N1 D5 M5) M M155=M
    <- data`join-left-preserves-leq* D2<=D4 D1+D2=D3 D1+D4=D5 D3<=D5
    <- join-left-preserves-leq* M2<=M4 M1+M2=M3 M1+M4=M5 M3<=M5
    <- leq-respects-eq (leq/= M3<=M5 D3<=D5 nat`eq/) eq/ M155=M M133<=M.

- : {M1+M044=M5:join M1 (map/+ N0 D4 M4) M5}
    {M115=M: eq (map/+ N1 D1 M5) M}
    join-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/)
                             (join/< M1+M022=M3 N0+1+N1=N2)
                             M111+M244=M M113<=M
    <- join/<-inversion M111+M244=M N0+1+N1=N2 M5 M1+M044=M5 M=M115
    <- eq-symmetric M=M115 M115=M
    <- meta-eq (map/+ N1 D1 M5) M M115=M
    <- join-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/) 
                                M1+M022=M3 M1+M044=M5 M3<=M5
    <- data`leq-reflexive _ D1<=D1
    <- leq-respects-eq (leq/= M3<=M5 D1<=D1 nat`eq/) eq/ M115=M M113<=M.

- : join-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/)
                             (join/> M311+M2=M3 N3+1+N2=N1)
                             M111+M244=M M223<=M
    <- join/>-inversion M111+M244=M N3+1+N2=N1 M5 M311+M4=M5 M=M245
    <- eq-symmetric M=M245 M245=M
    <- meta-eq (map/+ N2 D4 M5) M M245=M
    <- join-left-preserves-leq* M2<=M4 M311+M2=M3 M311+M4=M5 M3<=M5
    <- leq-respects-eq (leq/= M3<=M5 D2<=D4 nat`eq/) eq/ M245=M M223<=M.

- : join-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)
                             (join/= M1+M2=M3 D1+D2=D3 nat`eq/)   % N1=N2
                             M211+M444=M M233<=M
    <- join/>-inversion M211+M444=M N6+1+N4=N2 M5 M611+M4=M5 M=M445
    <- eq-symmetric M=M445 M445=M
    <- meta-eq (map/+ N4 D4 M5) M M445=M
    <- join-left-preserves-leq* M622<=M4 (join/= M1+M2=M3 D1+D2=D3 nat`eq/)
                                M611+M4=M5 M633<=M5
    <- leq-respects-eq (leq/> M633<=M5 N6+1+N4=N2) eq/ M445=M M233<=M.

- : join-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)
                             (join/< M1+M022=M3 N0+1+N4=N2)
                             (join/= M1+M4=M5 D1+D4=D5 nat`eq/)
                             (leq/= M3<=M5 D1<=D5 nat`eq/)
    <- nat`plus-right-cancels N6+1+N4=N2 N0+1+N4=N2 nat`eq/ nat`eq/ N6+1=N0+1
    <- nat`succ-cancels N6+1=N0+1 N6=N0
    <- map/+-preserves-eq N6=N0 data`eq/ eq/ M622=M022
    <- leq-respects-eq M622<=M4 M622=M022 eq/ M022<=M4
    <- join-left-preserves-leq* M022<=M4 M1+M022=M3 M1+M4=M5 M3<=M5
    <- data`join-implies-leq* D1+D4=D5 D1<=D5.

- : join-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)
                             (join/< M1+M022=M3 N0+1+N1=N2)
                             (join/< M1+M544=M5 N5+1+N1=N4)
                             (leq/= M3<=M5 D1<=D1 nat`eq/)
    <- nat`plus-swap-succ N5+1+N1=N4 N5+N1+1=N4
    <- nat`plus-associative-converse N5+N1+1=N4 N6+1+N4=N2 
                                     N0' N6+1+N5=N0' N0'+N1+1=N2
    <- nat`plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- nat`plus-right-cancels N0'+N1+1=N2 N0+N1+1=N2 nat`eq/ nat`eq/ N0'=N0
    <- nat`plus-respects-eq N6+1+N5=N0' nat`eq/ nat`eq/ N0'=N0 N6+1+N5=N0
    <- join-left-preserves-leq* (leq/> M622<=M4 N6+1+N5=N0) 
                                M1+M022=M3 M1+M544=M5 M3<=M5
    <- data`leq-reflexive _ D1<=D1.
       

% for some reason, twelf needs a lot of help inferring types here:
- : join-left-preserves-leq* ((leq/> M622<=M4 N6+1+N4=N2):leq (map/+ N2 D2 M2) (map/+ N4 D4 M4))
                             (join/< M1+M022=M3 N0+1+N1=N2)
                             (join/> M511+M4=M5 N5+1+N4=N1)
                             (leq/> M513<=M5 N5+1+N4=N1)
    <- nat`plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- nat`plus-associative-converse N5+N4+1=N1 N0+1+N1=N2 
                                     N6' N0+1+N5=N6' N6'+N4+1=N2
    <- nat`plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- nat`plus-right-cancels N6'+N4+1=N2 N6+N4+1=N2 nat`eq/ nat`eq/ N6'=N6
    <- nat`plus-respects-eq N0+1+N5=N6' nat`eq/ nat`eq/ N6'=N6 N0+1+N5=N6
    <- join-left-preserves-leq* M622<=M4 
       ((join/< M1+M022=M3 N0+1+N5=N6):join (map/+ N5 D1 M1) (map/+ N6 D2 M2)
                                            (map/+ N5 D1 M3))
                                M511+M4=M5 M513<=M5.

- : join-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)
                             (join/> M311+M2=M3 N3+1+N2=N1) 
                             M111+M444=M M223<=M
    <- nat`plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- nat`plus-associative-converse N6+N4+1=N2 N3+1+N2=N1 
                                     N5 N3+1+N6=N5 N5+N4+1=N1
    <- nat`plus-swap-succ-converse N5+N4+1=N1 N5+1+N4=N1 
    <- join/>-inversion M111+M444=M N5+1+N4=N1 M5 M511+M4=M5 M=M445
    <- eq-symmetric M=M445 M445=M
    <- meta-eq _ _ M445=M
    <- join-left-preserves-leq* M622<=M4 (join/> M311+M2=M3 N3+1+N6=N5)
                                M511+M4=M5 M623<=M5
    <- leq-respects-eq (leq/> M623<=M5 N6+1+N4=N2) eq/ M445=M M223<=M.
  
%worlds () (join-left-preserves-leq* _ _ _ _).
%total (J) (join-left-preserves-leq* _ _ J _).

%{%
#ifdef DATA_JOIN_LEFT_CANCELS
#ifdef DATA_JOIN_COMMUTATIVE
#ifdef DATA_JOIN_IMPLIES_LEQ
#ifdef LEQ_IMPLIES_JOIN
%}%

%theorem join-left-cancels-leq :
	forall* {M1} {M2} {M3} {M1P} {M2P} {M3P}
	forall {A:join M1 M2 M3} {AP:join M1P M2P M3P}
               {E:eq M1 M1P} {L:leq M3 M3P}
        exists {LP:leq M2 M2P}
	true.

- : join-left-cancels-leq M1+M2=M3 M1+M2P=M3P eq/ M3<=M3P M2<=M2P
    <- leq-implies-join M3<=M3P M M+M3=M3P
    <- join-commutative M+M3=M3P M3+M=M3P
    <- join-associative M1+M2=M3 M3+M=M3P M2M M2+M=M2M M1+M2M=M3P
    <- join-left-cancels M1+M2M=M3P M1+M2P=M3P eq/ eq/ M2M=M2P
    <- join-implies-leq* M2+M=M2M M2<=M2M
    <- leq-respects-eq M2<=M2M eq/ M2M=M2P M2<=M2P.

%worlds () (join-left-cancels-leq _ _ _ _ _).
%total { } (join-left-cancels-leq _ _ _ _ _).

%{%
#define OP_CANCELS 1
#define EQ eq
#endif
#endif
#endif
#endif

#define OPN join
#define OP(X,Y) X+Y
#define CMPN leq
#define CMP(X,Y) X<=Y
#ifdef DATA_JOIN_COMMUTATIVE
#define OP_COMMUTATIVE 1
#endif
#ifdef DATA_JOIN_TOTAL 1
#define OP_TOTAL 1
#endif
#define CMP_TRANSITIVE 1
BEGIN_ELF
#include "OPN-preserves-CMPN.i"
END_ELF
#undef CMP_TRANSITIVE
#undef OP_TOTAL
#undef OP_COMMUTATIVE
#undef CMP
#undef CMPN
#undef OP
#undef OPN
#undef CMP_IFF_OP
#undef OP_CANCELS

#endif /* DATA_JOIN_PRESERVES_LEQ */
%}%
