%%%%% bool.elf
%%%%% Boolean literals
%%%%% John Boyland


%%%% Definitions



bool : type.


true : bool.

false : bool.


%freeze bool.



eq : bool -> bool -> type.


eq/ : eq B B.



ne : bool -> bool -> type.


ne/TF : ne true false.

ne/FT : ne false true.



eq? : bool -> bool -> bool -> type.


eq?/yes : eq? B B true.

eq?/no : eq? B1 B2 false
    <- ne B1 B2.




%%%% Theorems



%%% theorems about eq

%{%
#define EQ eq
BEGIN_ELF
#include "EQ.i"
END_ELF
%}%


%%% theorems about ne

%{%
#define RELN ne
#define REL(X,Y) X<>Y
BEGIN_ELF
#include "RELN.i"
END_ELF
#undef RELN
#undef REL
#undef EQ
%}%


%theorem ne-anti-reflexive :
	forall* {B}
	forall {R:ne B B}
	exists {F:void}
	true.

%worlds () (ne-anti-reflexive _ _).
%total { } (ne-anti-reflexive _ _).


%theorem ne-symmetric :
	forall* {B1} {B2}
	forall {R1:ne B1 B2}
	exists {R2:ne B2 B1}
	true.

- : ne-symmetric ne/TF ne/FT.

- : ne-symmetric ne/FT ne/TF.

%worlds () (ne-symmetric _ _).
%total { } (ne-symmetric _ _).


%theorem eq-ne-implies-false :
	forall* {B1} {B2}
	forall {D1:eq B1 B2} {D2:ne B1 B2}
	exists {F:void}
	true.

%worlds () (eq-ne-implies-false _ _ _).
%total { } (eq-ne-implies-false _ _ _).



%%% theorems about eq?


%theorem eq?-total* :
	forall {B1} {B2}
	exists {B} {EQ?:eq? B1 B2 B}
	true.

- : eq?-total* true true _ (eq?/yes).

- : eq?-total* false false _ (eq?/yes).
	
- : eq?-total* true false _ (eq?/no ne/TF).

- : eq?-total* false true _ (eq?/no ne/FT).


%worlds () (eq?-total* _ _ _ _).
%total { } (eq?-total* _ _ _ _).


%abbrev eq?-total = eq?-total* _ _ _.
