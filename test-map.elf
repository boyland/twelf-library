data : type.

data/1 : data.
data/2 : data.

data`eq? : data -> data -> bool -> type.
%abbrev data`eq : data -> data -> type = [D1] [D2] data`eq? D1 D2 true.
%abbrev data`ne : data -> data -> type = [D1] [D2] data`eq? D1 D2 false.

data`eq/ : data`eq D D.

%abbrev data`eq?/yes = data`eq/.

data`ne/12 : data`ne data/1 data/2.
data`ne/21 : data`ne data/2 data/1.

%abbrev data`eq?/no = [D: data`ne D1 D2] D.

%theorem data`false-implies-eq? :
	forall* {D1} {D2} {B}
	forall	{F: void}
	exists	{EQ?: data`eq? D1 D2 B}
	true.

%worlds () (data`false-implies-eq? _ _).
%total { } (data`false-implies-eq? _ _).

%abbrev data`false-implies-eq = data`false-implies-eq?.
%abbrev data`false-implies-ne = data`false-implies-eq?.

%theorem data`ne-anti-reflexive:
	forall* {D}
	forall	{NE: data`ne D D}
	exists	{F:void}
	true.

%worlds () (data`ne-anti-reflexive _ _).
%total { } (data`ne-anti-reflexive _ _).

%theorem data`ne-symmetric:
	forall* {D1} {D2}
	forall	{NE12: data`ne D1 D2}
	exists	{NE21: data`ne D2 D1}
	true.

- : data`ne-symmetric data`ne/12 data`ne/21.

- : data`ne-symmetric data`ne/21 data`ne/12.

%worlds () (data`ne-symmetric _ _).
%total { } (data`ne-symmetric _ _).

%theorem data`eq?-total*:
	forall {D1} {D2}
	exists {B} {E:data`eq? D1 D2 B}
	true.
%abbrev data`eq?-total = data`eq?-total* _ _ _.

- : data`eq?-total data`eq/.

- : data`eq?-total data`ne/12.

- : data`eq?-total data`ne/21.

%worlds () (data`eq?-total* _ _ _ _).
%total { } (data`eq?-total* _ _ _ _).

%theorem data`eq-ne-implies-false :
	forall* {D1} {D2}
	forall	{EQ: data`eq D1 D2}
		{NE: data`ne D1 D2}
	exists	{F: void}
	true.

%worlds () (data`eq-ne-implies-false _ _ _).
%total { } (data`eq-ne-implies-false _ _ _).


%%% leq

data`leq? : data -> data -> bool -> type.

%abbrev data`leq : data -> data -> type = [D1] [D2] data`leq? D1 D2 true.

%abbrev data`nle : data -> data -> type = [D1] [D2] data`leq? D1 D2 false.

data`leq/1 : data`leq data/1 D.

data`leq/2 : data`leq data/2 data/2.

data`nle/ : data`nle data/2 data/1.

%abbrev data`leq?/yes : data`leq L1 L2 -> data`leq? L1 L2 true = [d] d.

%abbrev data`leq?/no : data`nle L1 L2 -> data`leq? L1 L2 false = [d] d.


%theorem data`false-implies-leq? :
	forall*	{D1} {D2} {B}
	forall	{F:void}
	exists	{L: data`leq? D1 D2 B}
	true.

%worlds () (data`false-implies-leq? _ _).
%total { } (data`false-implies-leq? _ _).

%abbrev data`false-implies-leq = data`false-implies-leq?.

%abbrev data`false-implies-nle = data`false-implies-leq?.


%theorem data`leq?-respects-eq :
	forall*	{D1} {D2} {D1P} {D2P} {B} {BP}
	forall	{L: data`leq? D1 D2 B}
		{E1: data`eq D1 D1P}
		{E2: data`eq D2 D2P}
		{EB: bool`eq B BP}
	exists	{LP: data`leq? D1P D2P BP}
	true.

- : data`leq?-respects-eq L _ _ _ L.

%worlds () (data`leq?-respects-eq _ _ _ _ _).
%total { } (data`leq?-respects-eq _ _ _ _ _).

%abbrev data`leq-respects-eq : 
	data`leq D1 D2 -> 
	data`eq D1 D1P -> 
	data`eq D2 D2P -> 
	data`leq D1P D2P ->
    type = [L] [E1] [E2] [LP] data`leq?-respects-eq L E1 E2 bool`eq/ LP.

%abbrev data`nle-respects-eq : 
	data`nle D1 D2 -> 
	data`eq D1 D1P -> 
	data`eq D2 D2P -> 
	data`nle D1P D2P ->
    type = [L] [E1] [E2] [LP] data`leq?-respects-eq L E1 E2 bool`eq/ LP.

%theorem data`leq-reflexive :
	forall	{D}
	exists	{L: data`leq D D}
	true.

- : data`leq-reflexive _ data`leq/1.

- : data`leq-reflexive _ data`leq/2.

%worlds () (data`leq-reflexive _ _).
%total { } (data`leq-reflexive _ _).


%theorem data`leq-anti-reflexive :
	forall* {D}
	forall	{L: data`leq D D}
	exists	{E: data`eq D D}
	true.

- : data`leq-anti-reflexive _ data`eq/.

%worlds () (data`leq-anti-reflexive _ _).
%total { } (data`leq-anti-reflexive _ _).


%theorem data`leq-anti-symmetric :
	forall*	{D1} {D2}
	forall	{L1: data`leq D1 D2}
		{L2: data`leq D2 D1}
	exists	{E: data`eq D1 D2}
	true.

- : data`leq-anti-symmetric _ _ data`eq/.

%worlds () (data`leq-anti-symmetric _ _ _).
%total { } (data`leq-anti-symmetric _ _ _).


%theorem data`leq-transitive :
	forall*	{D1} {D2} {D3}
	forall	{L1: data`leq D1 D2}
		{L2: data`leq D2 D3}
	exists	{L3: data`leq D1 D3}
	true.

- : data`leq-transitive data`leq/2 data`leq/2 data`leq/2.

- : data`leq-transitive data`leq/1 _ data`leq/1.

%worlds () (data`leq-transitive _ _ _).
%total { } (data`leq-transitive _ _ _).


%theorem data`nle-anti-reflexive :
	forall*	{D}
	forall	{L: data`nle D D}
	exists	{F: void}
	true.

%worlds () (data`nle-anti-reflexive _ _).
%total { } (data`nle-anti-reflexive _ _).

%theorem data`nle-anti-symmetric :
	forall* {D1} {D2}
	forall	{L1: data`nle D1 D2}
		{L2: data`nle D2 D1}
	exists	{F: void}
	true.

%worlds () (data`nle-anti-symmetric _ _ _).
%total { } (data`nle-anti-symmetric _ _ _).


%theorem data`nle-implies-ne :
	forall*	{D1} {D2}
	forall	{N: data`nle D1 D2}
	exists	{N: data`ne D1 D2}
	true.

- : data`nle-implies-ne _ data`ne/21.

%worlds () (data`nle-implies-ne _ _).
%total { } (data`nle-implies-ne _ _).


%theorem data`leq-nle-contradiction :
	forall*	{D1} {D2}
	forall	{L: data`leq D1 D2}
		{N: data`nle D1 D2}
	exists	{F:void}
	true.

%worlds () (data`leq-nle-contradiction _ _ _).
%total { } (data`leq-nle-contradiction _ _ _).


%theorem data`leq?-total* :
	forall	{D1} {D2}
	exists	{B}
		{L: data`leq? D1 D2 B}
	true.

%abbrev data`leq?-total = data`leq?-total* _ _ _.

- : data`leq?-total data`leq/1.

- : data`leq?-total data`leq/2.

- : data`leq?-total data`nle/.

%worlds () (data`leq?-total* _ _ _ _).
%total { } (data`leq?-total* _ _ _ _).



%%% Join


data`join : data -> data -> data -> type.


data`join/L : data`join data/1 D D.

data`join/R : data`join D data/1 D.

data`join/2 : data`join data/2 data/2 data/2.


%theorem data`false-implies-join :
	forall*	{D1} {D2} {D3}
	forall	{F:void}
	exists	{J: data`join D1 D2 D3}
	true.

%worlds () (data`false-implies-join _ _).
%total { } (data`false-implies-join _ _).


%theorem data`join-respects-eq :
	forall*	{D1} {D2} {D3} {E1} {E2} {E3}
	forall	{JD: data`join D1 D2 D3}
		{Q1: data`eq D1 E1}
		{Q2: data`eq D2 E2}
		{Q3: data`eq D3 E3}
	exists	{JE: data`join E1 E2 E3}
	true.

- : data`join-respects-eq J _ _ _ J.

%worlds () (data`join-respects-eq _ _ _ _ _).
%total { } (data`join-respects-eq _ _ _ _ _).


%theorem data`join-total* :
	forall	{D1} {D2}
	exists	{D3} 
		{J: data`join D1 D2 D3}
	true.

%abbrev data`join-total = data`join-total* _ _ _.

- : data`join-total data`join/L.

- : data`join-total data`join/R.

- : data`join-total data`join/2.

%worlds () (data`join-total* _ _ _ _).
%total { } (data`join-total* _ _ _ _).


%theorem data`join-unique :
	forall*	{D1} {D2} {D3} {E1} {E2} {E3}
	forall	{JD: data`join D1 D2 D3}
		{JE: data`join E1 E2 E3}
		{Q1: data`eq D1 E1}
		{Q2: data`eq D2 E2}
	exists	{Q3: data`eq D3 E3}
	true.

- : data`join-unique _ _ _ _ data`eq/.

%worlds () (data`join-unique _ _ _ _ _).
%total { } (data`join-unique _ _ _ _ _).

%abbrev data`join-deterministic = data`join-unique.


%theorem data`join-commutative :
	forall*	{D1} {D2} {D3}
	forall	{J: data`join D1 D2 D3}
	exists	{J: data`join D2 D1 D3}
	true.

- : data`join-commutative data`join/L data`join/R.

- : data`join-commutative data`join/R data`join/L.

- : data`join-commutative data`join/2 data`join/2.

%worlds () (data`join-commutative _ _).
%total { } (data`join-commutative _ _).


%theorem data`join-associative* :
	forall*	{D1} {D2} {D3} {D4} {D6} {D7}
	forall	{J12: data`join D1 D2 D3}
		{J34: data`join D3 D4 D7}
		{J24: data`join D2 D4 D6}
	exists	{J16: data`join D1 D6 D7}
	true.

- : data`join-associative* _ _ _ data`join/L.

- : data`join-associative* _ _ _ data`join/R.

- : data`join-associative* _ _ _ data`join/2.

%worlds () (data`join-associative* _ _ _ _).
%total { } (data`join-associative* _ _ _ _).


%theorem data`join-associative :
	forall*	{D1} {D2} {D3} {D4} {D7}
	forall	{J12: data`join D1 D2 D3}
		{J34: data`join D3 D4 D7}
	exists	{D6}
		{J24: data`join D2 D4 D6}
		{J16: data`join D1 D6 D7}
	true.

- : data`join-associative J12 J34 _ J24 J16
    <- data`join-total J24
    <- data`join-associative* J12 J34 J24 J16.

%worlds () (data`join-associative _ _ _ _ _).
%total { } (data`join-associative _ _ _ _ _).


%theorem data`join-idempotent :
	forall	{D}
	exists	{J:data`join D D D}
	true.

- : data`join-idempotent _ data`join/L.

- : data`join-idempotent _ data`join/2.

%worlds () (data`join-idempotent _ _).
%total { } (data`join-idempotent _ _).


%theorem data`join-cross-comparable :
	forall* {C} {C1} {C2} {C3} {C4}
	forall {A12:data`join C1 C2 C} {A34:data`join C3 C4 C}
	exists {C13} {C14} {C23} {C24}
	       {A1:data`join C13 C14 C1} {A2:data`join C23 C24 C2}
	       {A3:data`join C13 C23 C3} {A4:data`join C14 C24 C4}
	true.

- : data`join-cross-comparable _ _ data/1 data/1 data/1 data/1
	data`join/L data`join/L data`join/L data`join/L.

- : data`join-cross-comparable A12 data`join/L _ _ _ _
	data`join/L data`join/L data`join/L A12.

- : data`join-cross-comparable A12 data`join/R _ _ _ _
	data`join/R data`join/R A12 data`join/L.

- : data`join-cross-comparable A12 data`join/2 _ _ _ _
	J1 J2 A12 A12
    <- data`join-idempotent _ J1
    <- data`join-idempotent _ J2.

%worlds () (data`join-cross-comparable _ _ _ _ _ _ _ _ _ _).
%total { } (data`join-cross-comparable _ _ _ _ _ _ _ _ _ _).


%theorem data`join-implies-leq* :
	forall*	{D1} {D2} {D3}
	forall	{J: data`join D1 D2 D3}
	exists	{L: data`leq D1 D3}
	true.

- : data`join-implies-leq* _ data`leq/1.

- : data`join-implies-leq* _ data`leq/2.

%worlds () (data`join-implies-leq* _ _).
%total { } (data`join-implies-leq* _ _).


%theorem data`leq-ne-implies-join :
	forall*	{D1} {D2}
	forall	{L: data`leq D1 D2}
		{N: data`ne D1 D2}
	exists	{D0}
		{J: data`join D0 D1 D2}
	true.

- : data`leq-ne-implies-join _ _ _ data`join/L.

- : data`leq-ne-implies-join _ _ _ data`join/R.

- : data`leq-ne-implies-join _ _ _ data`join/2.

%worlds () (data`leq-ne-implies-join _ _ _ _).
%total { } (data`leq-ne-implies-join _ _ _ _).


%theorem data`join-is-lub :
	forall* {M1} {M2} {M3} {M4}
	forall  {J:data`join M1 M2 M3}
	        {L1:data`leq M1 M4} 
		{L2:data`leq M2 M4}
	exists  {L3:data`leq M3 M4}
	true.

- : data`join-is-lub _ _ _ data`leq/1.

- : data`join-is-lub _ _ _ data`leq/2.

%worlds () (data`join-is-lub _ _ _ _).
%total { } (data`join-is-lub _ _ _ _).


%theorem data`join-left-preserves-leq* :
	forall* {M1} {M2} {M3} {M4} {M5}
	forall  {L1:data`leq M2 M4}
                {J: data`join M1 M2 M3} 
		{JP:data`join M1 M4 M5}
	exists  {L3:data`leq M3 M5}
	true.

- : data`join-left-preserves-leq* _ _ _ data`leq/1.

- : data`join-left-preserves-leq* _ _ _ data`leq/2.

%worlds () (data`join-left-preserves-leq* _ _ _ _).
%total { } (data`join-left-preserves-leq* _ _ _ _).



%%% meet


data`meet : data -> data -> data -> type.


data`meet/L : data`meet data/2 D D.

data`meet/R : data`meet D data/2 D.

data`meet/1 : data`meet data/1 data/1 data/1.


%theorem data`false-implies-meet :
	forall*	{D1} {D2} {D3}
	forall	{F:void}
	exists	{J: data`meet D1 D2 D3}
	true.

%worlds () (data`false-implies-meet _ _).
%total { } (data`false-implies-meet _ _).


%theorem data`meet-respects-eq :
	forall*	{D1} {D2} {D3} {E1} {E2} {E3}
	forall	{JD: data`meet D1 D2 D3}
		{Q1: data`eq D1 E1}
		{Q2: data`eq D2 E2}
		{Q3: data`eq D3 E3}
	exists	{JE: data`meet E1 E2 E3}
	true.

- : data`meet-respects-eq J _ _ _ J.

%worlds () (data`meet-respects-eq _ _ _ _ _).
%total { } (data`meet-respects-eq _ _ _ _ _).


%theorem data`meet-total* :
	forall	{D1} {D2}
	exists	{D3} 
		{J: data`meet D1 D2 D3}
	true.

%abbrev data`meet-total = data`meet-total* _ _ _.

- : data`meet-total data`meet/L.

- : data`meet-total data`meet/R.

- : data`meet-total data`meet/1.

%worlds () (data`meet-total* _ _ _ _).
%total { } (data`meet-total* _ _ _ _).


%theorem data`meet-unique :
	forall*	{D1} {D2} {D3} {E1} {E2} {E3}
	forall	{JD: data`meet D1 D2 D3}
		{JE: data`meet E1 E2 E3}
		{Q1: data`eq D1 E1}
		{Q2: data`eq D2 E2}
	exists	{Q3: data`eq D3 E3}
	true.

- : data`meet-unique _ _ _ _ data`eq/.

%worlds () (data`meet-unique _ _ _ _ _).
%total { } (data`meet-unique _ _ _ _ _).

%abbrev data`meet-deterministic = data`meet-unique.


%theorem data`meet-commutative :
	forall*	{D1} {D2} {D3}
	forall	{J: data`meet D1 D2 D3}
	exists	{J: data`meet D2 D1 D3}
	true.

- : data`meet-commutative data`meet/L data`meet/R.

- : data`meet-commutative data`meet/R data`meet/L.

- : data`meet-commutative data`meet/1 data`meet/1.

%worlds () (data`meet-commutative _ _).
%total { } (data`meet-commutative _ _).


%theorem data`meet-associative* :
	forall*	{D1} {D2} {D3} {D4} {D6} {D7}
	forall	{J12: data`meet D1 D2 D3}
		{J34: data`meet D3 D4 D7}
		{J24: data`meet D2 D4 D6}
	exists	{J16: data`meet D1 D6 D7}
	true.

- : data`meet-associative* _ _ _ data`meet/L.

- : data`meet-associative* _ _ _ data`meet/R.

- : data`meet-associative* _ _ _ data`meet/1.

%worlds () (data`meet-associative* _ _ _ _).
%total { } (data`meet-associative* _ _ _ _).


%theorem data`meet-associative :
	forall*	{D1} {D2} {D3} {D4} {D7}
	forall	{J12: data`meet D1 D2 D3}
		{J34: data`meet D3 D4 D7}
	exists	{D6}
		{J24: data`meet D2 D4 D6}
		{J16: data`meet D1 D6 D7}
	true.

- : data`meet-associative J12 J34 _ J24 J16
    <- data`meet-total J24
    <- data`meet-associative* J12 J34 J24 J16.

%worlds () (data`meet-associative _ _ _ _ _).
%total { } (data`meet-associative _ _ _ _ _).


%theorem data`meet-idempotent :
	forall	{D}
	exists	{J:data`meet D D D}
	true.

- : data`meet-idempotent _ data`meet/L.

- : data`meet-idempotent _ data`meet/1.

%worlds () (data`meet-idempotent _ _).
%total { } (data`meet-idempotent _ _).


%theorem data`meet-cross-comparable :
	forall* {C} {C1} {C2} {C3} {C4}
	forall {A12:data`meet C1 C2 C} {A34:data`meet C3 C4 C}
	exists {C13} {C14} {C23} {C24}
	       {A1:data`meet C13 C14 C1} {A2:data`meet C23 C24 C2}
	       {A3:data`meet C13 C23 C3} {A4:data`meet C14 C24 C4}
	true.

- : data`meet-cross-comparable _ _ data/2 data/2 data/2 data/2
	data`meet/L data`meet/L data`meet/L data`meet/L.

- : data`meet-cross-comparable A12 data`meet/L _ _ _ _
	data`meet/L data`meet/L data`meet/L A12.

- : data`meet-cross-comparable A12 data`meet/R _ _ _ _
	data`meet/R data`meet/R A12 data`meet/L.

- : data`meet-cross-comparable A12 data`meet/1 _ _ _ _
	J1 J2 A12 A12
    <- data`meet-idempotent _ J1
    <- data`meet-idempotent _ J2.

%worlds () (data`meet-cross-comparable _ _ _ _ _ _ _ _ _ _).
%total { } (data`meet-cross-comparable _ _ _ _ _ _ _ _ _ _).


%theorem data`meet-implies-leq* :
	forall*	{D1} {D2} {D3}
	forall	{J: data`meet D1 D2 D3}
	exists	{L: data`leq D3 D1}
	true.

- : data`meet-implies-leq* _ data`leq/1.

- : data`meet-implies-leq* _ data`leq/2.

%worlds () (data`meet-implies-leq* _ _).
%total { } (data`meet-implies-leq* _ _).

%{%

%theorem data`leq-ne-implies-meet :
	forall*	{D1} {D2}
	forall	{L: data`leq D1 D2}
		{N: data`ne D1 D2}
	exists	{D0}
		{J: data`meet D0 D1 D2}
	true.

- : data`leq-ne-implies-meet _ _ _ data`meet/L.

- : data`leq-ne-implies-meet _ _ _ data`meet/R.

- : data`leq-ne-implies-meet _ _ _ data`meet/2.

%worlds () (data`leq-ne-implies-meet _ _ _ _).
%total { } (data`leq-ne-implies-meet _ _ _ _).

%}%

%theorem data`meet-is-glb :
	forall* {M1} {M2} {M3} {M0}
	forall  {J:data`meet M1 M2 M3}
	        {L1:data`leq M0 M1} 
		{L2:data`leq M0 M2}
	exists  {L3:data`leq M0 M3}
	true.

- : data`meet-is-glb _ _ _ data`leq/1.

- : data`meet-is-glb _ _ _ data`leq/2.

%worlds () (data`meet-is-glb _ _ _ _).
%total { } (data`meet-is-glb _ _ _ _).


%theorem data`meet-left-preserves-leq* :
	forall* {M1} {M2} {M3} {M4} {M5}
	forall  {L1:data`leq M2 M4}
                {J: data`meet M1 M2 M3} 
		{JP:data`meet M1 M4 M5}
	exists  {L3:data`leq M3 M5}
	true.

- : data`meet-left-preserves-leq* _ _ _ data`leq/1.

- : data`meet-left-preserves-leq* _ _ _ data`leq/2.

%worlds () (data`meet-left-preserves-leq* _ _ _ _).
%total { } (data`meet-left-preserves-leq* _ _ _ _).


%theorem data`meet-right-distributes-over-join* :
	forall* {M1} {M2} {M3} {M4} {M7} {M5} {M6}
        forall  {J12:data`join M1 M2 M3} {A34:data`meet M3 M4 M7}
		{A14:data`meet M1 M4 M5} {A24:data`meet M2 M4 M6}
        exists  {J56:data`join M5 M6 M7}
	true.

- : data`meet-right-distributes-over-join* _ _ _ _ data`join/L.

- : data`meet-right-distributes-over-join* _ _ _ _ data`join/R.

- : data`meet-right-distributes-over-join* _ _ _ _ data`join/2.

%worlds () (data`meet-right-distributes-over-join* _ _ _ _ _).
%total { } (data`meet-right-distributes-over-join* _ _ _ _ _).


%theorem data`meet-right-distributes-over-join :
	forall* {M1} {M2} {M3} {M4} {M7}
        forall  {J12:data`join M1 M2 M3} {A34:data`meet M3 M4 M7}
        exists  {M5} {M6} 
		{A14:data`meet M1 M4 M5} {A24:data`meet M2 M4 M6}
                {J56:data`join M5 M6 M7}
	true.

- : data`meet-right-distributes-over-join J12 A34 _ _ A14 A24 J56
    <- data`meet-total A14
    <- data`meet-total A24
    <- data`meet-right-distributes-over-join* J12 A34 A14 A24 J56.

%worlds () (data`meet-right-distributes-over-join _ _ _ _ _ _ _).
%total { } (data`meet-right-distributes-over-join _ _ _ _ _ _ _).


hypo : type.
%block WORLDS : block {x:hypo}.
